// This file is auto-generated by @hey-api/openapi-ts

import { type Options, restoreUser, deleteRole, getRoleById, updateRole, deletePermission, getPermissionById, updatePermission, updateUserImage, updateCurrentUserInfo, updateUserAccount, getUserLoginStatus, updateUserLoginStatus, getLoginStatus, updateLoginStatus, getMySetting, updateMySetting, updateReportStatus, bulkUpdateReports, deletePost, getPostById, updatePost, deleteTag, getTagById, updateTag, removeAllTagsFromPost, updatePostTags, bulkUpdatePosts, deleteComment, getCommentById, updateComment, bulkUpdateComments, updateUserInfo, updateUserAccount1, bulkUpdateUsers, bulkDeletePosts, bulkUpdatePosts1, bulkUpdateNotifications, updateNotificationById, createUser, getAllRoles, createRole, syncPermissionsForRole, assignPermissionsToRole, getAllPermissions, createPermission, generateUploadSignature, createAsset, searchReports, createReport, createPost, recordView, getInteractionsByPostId, createInteraction, deleteBookmark, isBookmarked, bookmarkPost, getAllTags, createTag, addTagsToPost, getPostCategories, createPostCategory, cleanupOldSoftDeletedNotifications, unfollow, follow, createComment, getInteractions, createInteraction1, enableMaintenance, disableMaintenance, getAllNotifications, createNotification, createAdminNotifications, getAllLogEntries, createLogEntry, deletePostCategory, updatePostCategory, unmarkNotificationAsRead, markNotificationAsRead, unmarkAllNotificationsAsRead, markAllNotificationsAsRead, unpinComment, pinComment, markAsUnread, markAsRead, isUserExists, getUserSummary, getUserIntroduction, getRoleBySlug, getPermissionBySlug, deleteCurrentUser, getCurrentUser, isUserExistsByAuth0Id, getVideoThumbnailUrl, getVideoPlaybackUrl, getAssetById, getAssetByPublicId, deleteReport, getReportById, getAllReports, getTotalViews, hasMeInteracted, getTotalViewsByUserId, getCountAllPostsByUserId, getAllPublicPostsByUserId, getTagsWithCounts, getTagWithCountById, getTagWithCountBySlug, getTagWithCountByName, getTagNamesByPostId, getTagsByPostId, getAllTagsWithCounts, getAllPublicPosts, getMeAllPosts, getPostCategoryByName, getCategoriesWithCounts, getCategoryWithCountByName, getCategoryWithCountById, getPostCategoryById, getAllCategoriesWithCounts, getNotificationById, getNotificationStatistics, getMyNotifications, getHistoriesByUserId, getHistoriesForMe, getOverview, getFollowingByUserId, getFollowersByUserId, getMyFollowing, getMyFollowers, isFriend, getFeed, getFeedByUserId, getFeed1, getAllCommentsByPostId, getModerationOverview, getUserModerationOverview, getPostModerationOverview, getCommentModerationOverview, getDailyPendingAndResolvedReports, getLogOverview, getDailyErrorLogs, getDailyLogsBySeverity, getNotificationTrends, getAdminNotificationOverview, getNotificationsByType, getNotificationsBySeverity, getAllUsers, deleteUser, getUser, getAllUserIntroductions, getSystemStatus, getStatusMaintenance, getDatabaseSchema, getAllPostsForAdmin, deletePost1, getPostByIdForAdmin, getAllPostWithDetailsForAdmin, deleteNotification, getNotificationById1, getAllNotificationByRecipientId, getLogEntryById, getAllComments, getAllCommentsWithPostDetails, getUserAnalyticsOverview, getDailyUserCounts, getTagAnalyticsOverview, getTagDistribution, getDailyTagCounts, getPostAnalytics, getDailyPostCount, getUsersPerDay, getPostsPerDay, getDashboardOverview, getCommentsPerDay, getAllDashboardData, getCommentAnalyticsOverview, getDailyCommentCounts, getCategoryAnalyticsOverview, getCategoryDistribution, getDailyCategoryCounts, getAll, bulkDeleteRoles, bulkDeletePermissions, deleteAsset, bulkDeleteReports, deleteInteraction, removeTagFromPost, bulkDeleteTags, deletePostCategories, softDeleteNotificationById, dismissAllNotifications, removeInteraction, bulkDeleteUsers, deleteAllUsers, deleteAllPostsByUser, bulkDeleteNotifications, forceDeleteNotificationById, bulkDeleteLogEntries, deleteMultipleComments, deleteAllComments } from '../sdk.gen';
import { type UseMutationOptions, type DefaultError, queryOptions, infiniteQueryOptions, type InfiniteData } from '@tanstack/react-query';
import type { RestoreUserData, RestoreUserResponse, DeleteRoleData, DeleteRoleResponse, GetRoleByIdData, UpdateRoleData, UpdateRoleResponse, DeletePermissionData, DeletePermissionResponse, GetPermissionByIdData, UpdatePermissionData, UpdatePermissionResponse, UpdateUserImageData, UpdateUserImageResponse, UpdateCurrentUserInfoData, UpdateCurrentUserInfoResponse, UpdateUserAccountData, UpdateUserAccountResponse, GetUserLoginStatusData, UpdateUserLoginStatusData, UpdateUserLoginStatusResponse, GetLoginStatusData, UpdateLoginStatusData, UpdateLoginStatusResponse, GetMySettingData, UpdateMySettingData, UpdateMySettingResponse, UpdateReportStatusData, UpdateReportStatusResponse, BulkUpdateReportsData, BulkUpdateReportsResponse, DeletePostData, DeletePostResponse, GetPostByIdData, UpdatePostData, UpdatePostResponse, DeleteTagData, DeleteTagResponse, GetTagByIdData, UpdateTagData, UpdateTagResponse, RemoveAllTagsFromPostData, RemoveAllTagsFromPostResponse, UpdatePostTagsData, UpdatePostTagsResponse, BulkUpdatePostsData, BulkUpdatePostsResponse, DeleteCommentData, DeleteCommentResponse, GetCommentByIdData, UpdateCommentData, UpdateCommentResponse, BulkUpdateCommentsData, BulkUpdateCommentsResponse, UpdateUserInfoData, UpdateUserInfoResponse, UpdateUserAccount1Data, UpdateUserAccount1Response, BulkUpdateUsersData, BulkUpdateUsersResponse, BulkDeletePostsData, BulkDeletePostsResponse, BulkUpdatePosts1Data, BulkUpdatePosts1Response, BulkUpdateNotificationsData, BulkUpdateNotificationsResponse, UpdateNotificationByIdData, UpdateNotificationByIdResponse, CreateUserData, CreateUserResponse, GetAllRolesData, GetAllRolesResponse, CreateRoleData, CreateRoleResponse, SyncPermissionsForRoleData, SyncPermissionsForRoleResponse, AssignPermissionsToRoleData, AssignPermissionsToRoleResponse, GetAllPermissionsData, GetAllPermissionsResponse, CreatePermissionData, CreatePermissionResponse, GenerateUploadSignatureData, GenerateUploadSignatureResponse, CreateAssetData, CreateAssetResponse, SearchReportsData, SearchReportsResponse, CreateReportData, CreateReportResponse, CreatePostData, CreatePostResponse, RecordViewData, RecordViewResponse, GetInteractionsByPostIdData, CreateInteractionData, CreateInteractionResponse, DeleteBookmarkData, DeleteBookmarkResponse, IsBookmarkedData, BookmarkPostData, BookmarkPostResponse, GetAllTagsData, GetAllTagsResponse, CreateTagData, CreateTagResponse, AddTagsToPostData, AddTagsToPostResponse, GetPostCategoriesData, GetPostCategoriesResponse, CreatePostCategoryData, CreatePostCategoryResponse, CleanupOldSoftDeletedNotificationsData, CleanupOldSoftDeletedNotificationsResponse, UnfollowData, UnfollowResponse, FollowData, FollowResponse, CreateCommentData, CreateCommentResponse, GetInteractionsData, CreateInteraction1Data, CreateInteraction1Response, EnableMaintenanceData, EnableMaintenanceResponse, DisableMaintenanceData, DisableMaintenanceResponse, GetAllNotificationsData, GetAllNotificationsResponse, CreateNotificationData, CreateNotificationResponse, CreateAdminNotificationsData, CreateAdminNotificationsResponse, GetAllLogEntriesData, GetAllLogEntriesResponse, CreateLogEntryData, CreateLogEntryResponse, DeletePostCategoryData, DeletePostCategoryResponse, UpdatePostCategoryData, UpdatePostCategoryResponse, UnmarkNotificationAsReadData, UnmarkNotificationAsReadResponse, MarkNotificationAsReadData, MarkNotificationAsReadResponse, UnmarkAllNotificationsAsReadData, UnmarkAllNotificationsAsReadResponse, MarkAllNotificationsAsReadData, MarkAllNotificationsAsReadResponse, UnpinCommentData, UnpinCommentResponse, PinCommentData, PinCommentResponse, MarkAsUnreadData, MarkAsUnreadResponse, MarkAsReadData, MarkAsReadResponse, IsUserExistsData, GetUserSummaryData, GetUserIntroductionData, GetRoleBySlugData, GetPermissionBySlugData, DeleteCurrentUserData, DeleteCurrentUserResponse, GetCurrentUserData, IsUserExistsByAuth0IdData, GetVideoThumbnailUrlData, GetVideoPlaybackUrlData, GetAssetByIdData, GetAssetByPublicIdData, DeleteReportData, DeleteReportResponse, GetReportByIdData, GetAllReportsData, GetAllReportsResponse, GetTotalViewsData, HasMeInteractedData, GetTotalViewsByUserIdData, GetCountAllPostsByUserIdData, GetAllPublicPostsByUserIdData, GetAllPublicPostsByUserIdResponse, GetTagsWithCountsData, GetTagsWithCountsResponse, GetTagWithCountByIdData, GetTagWithCountBySlugData, GetTagWithCountByNameData, GetTagNamesByPostIdData, GetTagsByPostIdData, GetAllTagsWithCountsData, GetAllPublicPostsData, GetMeAllPostsData, GetPostCategoryByNameData, GetCategoriesWithCountsData, GetCategoriesWithCountsResponse, GetCategoryWithCountByNameData, GetCategoryWithCountByIdData, GetPostCategoryByIdData, GetAllCategoriesWithCountsData, GetNotificationByIdData, GetNotificationStatisticsData, GetMyNotificationsData, GetMyNotificationsResponse, GetHistoriesByUserIdData, GetHistoriesByUserIdResponse, GetHistoriesForMeData, GetHistoriesForMeResponse, GetOverviewData, GetFollowingByUserIdData, GetFollowingByUserIdResponse, GetFollowersByUserIdData, GetFollowersByUserIdResponse, GetMyFollowingData, GetMyFollowingResponse, GetMyFollowersData, GetMyFollowersResponse, IsFriendData, GetFeedData, GetFeedResponse, GetFeedByUserIdData, GetFeedByUserIdResponse, GetFeed1Data, GetAllCommentsByPostIdData, GetAllCommentsByPostIdResponse, GetModerationOverviewData, GetUserModerationOverviewData, GetPostModerationOverviewData, GetCommentModerationOverviewData, GetDailyPendingAndResolvedReportsData, GetLogOverviewData, GetDailyErrorLogsData, GetDailyLogsBySeverityData, GetNotificationTrendsData, GetAdminNotificationOverviewData, GetNotificationsByTypeData, GetNotificationsBySeverityData, GetAllUsersData, GetAllUsersResponse, DeleteUserData, DeleteUserResponse, GetUserData, GetAllUserIntroductionsData, GetAllUserIntroductionsResponse, GetSystemStatusData, GetStatusMaintenanceData, GetDatabaseSchemaData, GetAllPostsForAdminData, GetAllPostsForAdminResponse, DeletePost1Data, DeletePost1Response, GetPostByIdForAdminData, GetAllPostWithDetailsForAdminData, GetAllPostWithDetailsForAdminResponse, DeleteNotificationData, DeleteNotificationResponse, GetNotificationById1Data, GetAllNotificationByRecipientIdData, GetAllNotificationByRecipientIdResponse, GetLogEntryByIdData, GetAllCommentsData, GetAllCommentsResponse, GetAllCommentsWithPostDetailsData, GetAllCommentsWithPostDetailsResponse, GetUserAnalyticsOverviewData, GetDailyUserCountsData, GetTagAnalyticsOverviewData, GetTagDistributionData, GetDailyTagCountsData, GetPostAnalyticsData, GetDailyPostCountData, GetUsersPerDayData, GetPostsPerDayData, GetDashboardOverviewData, GetCommentsPerDayData, GetAllDashboardDataData, GetCommentAnalyticsOverviewData, GetDailyCommentCountsData, GetCategoryAnalyticsOverviewData, GetCategoryDistributionData, GetDailyCategoryCountsData, GetAllData, GetAllResponse, BulkDeleteRolesData, BulkDeleteRolesResponse, BulkDeletePermissionsData, BulkDeletePermissionsResponse, DeleteAssetData, DeleteAssetResponse, BulkDeleteReportsData, BulkDeleteReportsResponse, DeleteInteractionData, DeleteInteractionResponse, RemoveTagFromPostData, RemoveTagFromPostResponse, BulkDeleteTagsData, BulkDeleteTagsResponse, DeletePostCategoriesData, DeletePostCategoriesResponse, SoftDeleteNotificationByIdData, SoftDeleteNotificationByIdResponse, DismissAllNotificationsData, DismissAllNotificationsResponse, RemoveInteractionData, RemoveInteractionResponse, BulkDeleteUsersData, BulkDeleteUsersResponse, DeleteAllUsersData, DeleteAllUsersResponse, DeleteAllPostsByUserData, DeleteAllPostsByUserResponse, BulkDeleteNotificationsData, BulkDeleteNotificationsResponse, ForceDeleteNotificationByIdData, ForceDeleteNotificationByIdResponse, BulkDeleteLogEntriesData, BulkDeleteLogEntriesResponse, DeleteMultipleCommentsData, DeleteMultipleCommentsResponse, DeleteAllCommentsData, DeleteAllCommentsResponse } from '../types.gen';
import type { AxiosError } from 'axios';
import { client as _heyApiClient } from '../client.gen';

export const restoreUserMutation = (options?: Partial<Options<RestoreUserData>>): UseMutationOptions<RestoreUserResponse, AxiosError<DefaultError>, Options<RestoreUserData>> => {
    const mutationOptions: UseMutationOptions<RestoreUserResponse, AxiosError<DefaultError>, Options<RestoreUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await restoreUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteRoleMutation = (options?: Partial<Options<DeleteRoleData>>): UseMutationOptions<DeleteRoleResponse, AxiosError<DefaultError>, Options<DeleteRoleData>> => {
    const mutationOptions: UseMutationOptions<DeleteRoleResponse, AxiosError<DefaultError>, Options<DeleteRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export type QueryKey<TOptions extends Options> = [
    Pick<TOptions, 'baseURL' | 'body' | 'headers' | 'path' | 'query'> & {
        _id: string;
        _infinite?: boolean;
    }
];

const createQueryKey = <TOptions extends Options>(id: string, options?: TOptions, infinite?: boolean): [
    QueryKey<TOptions>[0]
] => {
    const params: QueryKey<TOptions>[0] = { _id: id, baseURL: (options?.client ?? _heyApiClient).getConfig().baseURL } as QueryKey<TOptions>[0];
    if (infinite) {
        params._infinite = infinite;
    }
    if (options?.body) {
        params.body = options.body;
    }
    if (options?.headers) {
        params.headers = options.headers;
    }
    if (options?.path) {
        params.path = options.path;
    }
    if (options?.query) {
        params.query = options.query;
    }
    return [
        params
    ];
};

export const getRoleByIdQueryKey = (options: Options<GetRoleByIdData>) => createQueryKey('getRoleById', options);

export const getRoleByIdOptions = (options: Options<GetRoleByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRoleById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRoleByIdQueryKey(options)
    });
};

export const updateRoleMutation = (options?: Partial<Options<UpdateRoleData>>): UseMutationOptions<UpdateRoleResponse, AxiosError<DefaultError>, Options<UpdateRoleData>> => {
    const mutationOptions: UseMutationOptions<UpdateRoleResponse, AxiosError<DefaultError>, Options<UpdateRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deletePermissionMutation = (options?: Partial<Options<DeletePermissionData>>): UseMutationOptions<DeletePermissionResponse, AxiosError<DefaultError>, Options<DeletePermissionData>> => {
    const mutationOptions: UseMutationOptions<DeletePermissionResponse, AxiosError<DefaultError>, Options<DeletePermissionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deletePermission({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPermissionByIdQueryKey = (options: Options<GetPermissionByIdData>) => createQueryKey('getPermissionById', options);

export const getPermissionByIdOptions = (options: Options<GetPermissionByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPermissionById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPermissionByIdQueryKey(options)
    });
};

export const updatePermissionMutation = (options?: Partial<Options<UpdatePermissionData>>): UseMutationOptions<UpdatePermissionResponse, AxiosError<DefaultError>, Options<UpdatePermissionData>> => {
    const mutationOptions: UseMutationOptions<UpdatePermissionResponse, AxiosError<DefaultError>, Options<UpdatePermissionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updatePermission({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateUserImageMutation = (options?: Partial<Options<UpdateUserImageData>>): UseMutationOptions<UpdateUserImageResponse, AxiosError<DefaultError>, Options<UpdateUserImageData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserImageResponse, AxiosError<DefaultError>, Options<UpdateUserImageData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUserImage({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateCurrentUserInfoMutation = (options?: Partial<Options<UpdateCurrentUserInfoData>>): UseMutationOptions<UpdateCurrentUserInfoResponse, AxiosError<DefaultError>, Options<UpdateCurrentUserInfoData>> => {
    const mutationOptions: UseMutationOptions<UpdateCurrentUserInfoResponse, AxiosError<DefaultError>, Options<UpdateCurrentUserInfoData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateCurrentUserInfo({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateUserAccountMutation = (options?: Partial<Options<UpdateUserAccountData>>): UseMutationOptions<UpdateUserAccountResponse, AxiosError<DefaultError>, Options<UpdateUserAccountData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserAccountResponse, AxiosError<DefaultError>, Options<UpdateUserAccountData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUserAccount({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserLoginStatusQueryKey = (options: Options<GetUserLoginStatusData>) => createQueryKey('getUserLoginStatus', options);

export const getUserLoginStatusOptions = (options: Options<GetUserLoginStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserLoginStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserLoginStatusQueryKey(options)
    });
};

export const updateUserLoginStatusMutation = (options?: Partial<Options<UpdateUserLoginStatusData>>): UseMutationOptions<UpdateUserLoginStatusResponse, AxiosError<DefaultError>, Options<UpdateUserLoginStatusData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserLoginStatusResponse, AxiosError<DefaultError>, Options<UpdateUserLoginStatusData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUserLoginStatus({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getLoginStatusQueryKey = (options?: Options<GetLoginStatusData>) => createQueryKey('getLoginStatus', options);

export const getLoginStatusOptions = (options?: Options<GetLoginStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLoginStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLoginStatusQueryKey(options)
    });
};

export const updateLoginStatusMutation = (options?: Partial<Options<UpdateLoginStatusData>>): UseMutationOptions<UpdateLoginStatusResponse, AxiosError<DefaultError>, Options<UpdateLoginStatusData>> => {
    const mutationOptions: UseMutationOptions<UpdateLoginStatusResponse, AxiosError<DefaultError>, Options<UpdateLoginStatusData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateLoginStatus({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getMySettingQueryKey = (options?: Options<GetMySettingData>) => createQueryKey('getMySetting', options);

export const getMySettingOptions = (options?: Options<GetMySettingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMySetting({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMySettingQueryKey(options)
    });
};

export const updateMySettingMutation = (options?: Partial<Options<UpdateMySettingData>>): UseMutationOptions<UpdateMySettingResponse, AxiosError<DefaultError>, Options<UpdateMySettingData>> => {
    const mutationOptions: UseMutationOptions<UpdateMySettingResponse, AxiosError<DefaultError>, Options<UpdateMySettingData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateMySetting({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateReportStatusMutation = (options?: Partial<Options<UpdateReportStatusData>>): UseMutationOptions<UpdateReportStatusResponse, AxiosError<DefaultError>, Options<UpdateReportStatusData>> => {
    const mutationOptions: UseMutationOptions<UpdateReportStatusResponse, AxiosError<DefaultError>, Options<UpdateReportStatusData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateReportStatus({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkUpdateReportsMutation = (options?: Partial<Options<BulkUpdateReportsData>>): UseMutationOptions<BulkUpdateReportsResponse, AxiosError<DefaultError>, Options<BulkUpdateReportsData>> => {
    const mutationOptions: UseMutationOptions<BulkUpdateReportsResponse, AxiosError<DefaultError>, Options<BulkUpdateReportsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkUpdateReports({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deletePostMutation = (options?: Partial<Options<DeletePostData>>): UseMutationOptions<DeletePostResponse, AxiosError<DefaultError>, Options<DeletePostData>> => {
    const mutationOptions: UseMutationOptions<DeletePostResponse, AxiosError<DefaultError>, Options<DeletePostData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deletePost({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPostByIdQueryKey = (options: Options<GetPostByIdData>) => createQueryKey('getPostById', options);

export const getPostByIdOptions = (options: Options<GetPostByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPostById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPostByIdQueryKey(options)
    });
};

export const updatePostMutation = (options?: Partial<Options<UpdatePostData>>): UseMutationOptions<UpdatePostResponse, AxiosError<DefaultError>, Options<UpdatePostData>> => {
    const mutationOptions: UseMutationOptions<UpdatePostResponse, AxiosError<DefaultError>, Options<UpdatePostData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updatePost({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteTagMutation = (options?: Partial<Options<DeleteTagData>>): UseMutationOptions<DeleteTagResponse, AxiosError<DefaultError>, Options<DeleteTagData>> => {
    const mutationOptions: UseMutationOptions<DeleteTagResponse, AxiosError<DefaultError>, Options<DeleteTagData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteTag({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getTagByIdQueryKey = (options: Options<GetTagByIdData>) => createQueryKey('getTagById', options);

export const getTagByIdOptions = (options: Options<GetTagByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagByIdQueryKey(options)
    });
};

export const updateTagMutation = (options?: Partial<Options<UpdateTagData>>): UseMutationOptions<UpdateTagResponse, AxiosError<DefaultError>, Options<UpdateTagData>> => {
    const mutationOptions: UseMutationOptions<UpdateTagResponse, AxiosError<DefaultError>, Options<UpdateTagData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateTag({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeAllTagsFromPostMutation = (options?: Partial<Options<RemoveAllTagsFromPostData>>): UseMutationOptions<RemoveAllTagsFromPostResponse, AxiosError<DefaultError>, Options<RemoveAllTagsFromPostData>> => {
    const mutationOptions: UseMutationOptions<RemoveAllTagsFromPostResponse, AxiosError<DefaultError>, Options<RemoveAllTagsFromPostData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeAllTagsFromPost({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updatePostTagsMutation = (options?: Partial<Options<UpdatePostTagsData>>): UseMutationOptions<UpdatePostTagsResponse, AxiosError<DefaultError>, Options<UpdatePostTagsData>> => {
    const mutationOptions: UseMutationOptions<UpdatePostTagsResponse, AxiosError<DefaultError>, Options<UpdatePostTagsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updatePostTags({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkUpdatePostsMutation = (options?: Partial<Options<BulkUpdatePostsData>>): UseMutationOptions<BulkUpdatePostsResponse, AxiosError<DefaultError>, Options<BulkUpdatePostsData>> => {
    const mutationOptions: UseMutationOptions<BulkUpdatePostsResponse, AxiosError<DefaultError>, Options<BulkUpdatePostsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkUpdatePosts({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteCommentMutation = (options?: Partial<Options<DeleteCommentData>>): UseMutationOptions<DeleteCommentResponse, AxiosError<DefaultError>, Options<DeleteCommentData>> => {
    const mutationOptions: UseMutationOptions<DeleteCommentResponse, AxiosError<DefaultError>, Options<DeleteCommentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteComment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCommentByIdQueryKey = (options: Options<GetCommentByIdData>) => createQueryKey('getCommentById', options);

export const getCommentByIdOptions = (options: Options<GetCommentByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCommentById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCommentByIdQueryKey(options)
    });
};

export const updateCommentMutation = (options?: Partial<Options<UpdateCommentData>>): UseMutationOptions<UpdateCommentResponse, AxiosError<DefaultError>, Options<UpdateCommentData>> => {
    const mutationOptions: UseMutationOptions<UpdateCommentResponse, AxiosError<DefaultError>, Options<UpdateCommentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateComment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkUpdateCommentsMutation = (options?: Partial<Options<BulkUpdateCommentsData>>): UseMutationOptions<BulkUpdateCommentsResponse, AxiosError<DefaultError>, Options<BulkUpdateCommentsData>> => {
    const mutationOptions: UseMutationOptions<BulkUpdateCommentsResponse, AxiosError<DefaultError>, Options<BulkUpdateCommentsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkUpdateComments({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateUserInfoMutation = (options?: Partial<Options<UpdateUserInfoData>>): UseMutationOptions<UpdateUserInfoResponse, AxiosError<DefaultError>, Options<UpdateUserInfoData>> => {
    const mutationOptions: UseMutationOptions<UpdateUserInfoResponse, AxiosError<DefaultError>, Options<UpdateUserInfoData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUserInfo({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateUserAccount1Mutation = (options?: Partial<Options<UpdateUserAccount1Data>>): UseMutationOptions<UpdateUserAccount1Response, AxiosError<DefaultError>, Options<UpdateUserAccount1Data>> => {
    const mutationOptions: UseMutationOptions<UpdateUserAccount1Response, AxiosError<DefaultError>, Options<UpdateUserAccount1Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateUserAccount1({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkUpdateUsersMutation = (options?: Partial<Options<BulkUpdateUsersData>>): UseMutationOptions<BulkUpdateUsersResponse, AxiosError<DefaultError>, Options<BulkUpdateUsersData>> => {
    const mutationOptions: UseMutationOptions<BulkUpdateUsersResponse, AxiosError<DefaultError>, Options<BulkUpdateUsersData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkUpdateUsers({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkDeletePostsMutation = (options?: Partial<Options<BulkDeletePostsData>>): UseMutationOptions<BulkDeletePostsResponse, AxiosError<DefaultError>, Options<BulkDeletePostsData>> => {
    const mutationOptions: UseMutationOptions<BulkDeletePostsResponse, AxiosError<DefaultError>, Options<BulkDeletePostsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkDeletePosts({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkUpdatePosts1Mutation = (options?: Partial<Options<BulkUpdatePosts1Data>>): UseMutationOptions<BulkUpdatePosts1Response, AxiosError<DefaultError>, Options<BulkUpdatePosts1Data>> => {
    const mutationOptions: UseMutationOptions<BulkUpdatePosts1Response, AxiosError<DefaultError>, Options<BulkUpdatePosts1Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkUpdatePosts1({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkUpdateNotificationsMutation = (options?: Partial<Options<BulkUpdateNotificationsData>>): UseMutationOptions<BulkUpdateNotificationsResponse, AxiosError<DefaultError>, Options<BulkUpdateNotificationsData>> => {
    const mutationOptions: UseMutationOptions<BulkUpdateNotificationsResponse, AxiosError<DefaultError>, Options<BulkUpdateNotificationsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkUpdateNotifications({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updateNotificationByIdMutation = (options?: Partial<Options<UpdateNotificationByIdData>>): UseMutationOptions<UpdateNotificationByIdResponse, AxiosError<DefaultError>, Options<UpdateNotificationByIdData>> => {
    const mutationOptions: UseMutationOptions<UpdateNotificationByIdResponse, AxiosError<DefaultError>, Options<UpdateNotificationByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updateNotificationById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createUserQueryKey = (options: Options<CreateUserData>) => createQueryKey('createUser', options);

export const createUserOptions = (options: Options<CreateUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createUserQueryKey(options)
    });
};

export const createUserMutation = (options?: Partial<Options<CreateUserData>>): UseMutationOptions<CreateUserResponse, AxiosError<DefaultError>, Options<CreateUserData>> => {
    const mutationOptions: UseMutationOptions<CreateUserResponse, AxiosError<DefaultError>, Options<CreateUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllRolesQueryKey = (options?: Options<GetAllRolesData>) => createQueryKey('getAllRoles', options);

export const getAllRolesOptions = (options?: Options<GetAllRolesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllRoles({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllRolesQueryKey(options)
    });
};

const createInfiniteParams = <K extends Pick<QueryKey<Options>[0], 'body' | 'headers' | 'path' | 'query'>>(queryKey: QueryKey<Options>, page: K) => {
    const params = queryKey[0];
    if (page.body) {
        params.body = {
            ...queryKey[0].body as any,
            ...page.body as any
        };
    }
    if (page.headers) {
        params.headers = {
            ...queryKey[0].headers,
            ...page.headers
        };
    }
    if (page.path) {
        params.path = {
            ...queryKey[0].path as any,
            ...page.path as any
        };
    }
    if (page.query) {
        params.query = {
            ...queryKey[0].query as any,
            ...page.query as any
        };
    }
    return params as unknown as typeof page;
};

export const getAllRolesInfiniteQueryKey = (options?: Options<GetAllRolesData>): QueryKey<Options<GetAllRolesData>> => createQueryKey('getAllRoles', options, true);

export const getAllRolesInfiniteOptions = (options?: Options<GetAllRolesData>) => {
    return infiniteQueryOptions<GetAllRolesResponse, AxiosError<DefaultError>, InfiniteData<GetAllRolesResponse>, QueryKey<Options<GetAllRolesData>>, number | Pick<QueryKey<Options<GetAllRolesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllRolesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllRoles({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllRolesInfiniteQueryKey(options)
    });
};

export const createRoleQueryKey = (options: Options<CreateRoleData>) => createQueryKey('createRole', options);

export const createRoleOptions = (options: Options<CreateRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createRoleQueryKey(options)
    });
};

export const createRoleMutation = (options?: Partial<Options<CreateRoleData>>): UseMutationOptions<CreateRoleResponse, AxiosError<DefaultError>, Options<CreateRoleData>> => {
    const mutationOptions: UseMutationOptions<CreateRoleResponse, AxiosError<DefaultError>, Options<CreateRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const syncPermissionsForRoleQueryKey = (options: Options<SyncPermissionsForRoleData>) => createQueryKey('syncPermissionsForRole', options);

export const syncPermissionsForRoleOptions = (options: Options<SyncPermissionsForRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await syncPermissionsForRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: syncPermissionsForRoleQueryKey(options)
    });
};

export const syncPermissionsForRoleMutation = (options?: Partial<Options<SyncPermissionsForRoleData>>): UseMutationOptions<SyncPermissionsForRoleResponse, AxiosError<DefaultError>, Options<SyncPermissionsForRoleData>> => {
    const mutationOptions: UseMutationOptions<SyncPermissionsForRoleResponse, AxiosError<DefaultError>, Options<SyncPermissionsForRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await syncPermissionsForRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const assignPermissionsToRoleQueryKey = (options: Options<AssignPermissionsToRoleData>) => createQueryKey('assignPermissionsToRole', options);

export const assignPermissionsToRoleOptions = (options: Options<AssignPermissionsToRoleData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await assignPermissionsToRole({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: assignPermissionsToRoleQueryKey(options)
    });
};

export const assignPermissionsToRoleMutation = (options?: Partial<Options<AssignPermissionsToRoleData>>): UseMutationOptions<AssignPermissionsToRoleResponse, AxiosError<DefaultError>, Options<AssignPermissionsToRoleData>> => {
    const mutationOptions: UseMutationOptions<AssignPermissionsToRoleResponse, AxiosError<DefaultError>, Options<AssignPermissionsToRoleData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await assignPermissionsToRole({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllPermissionsQueryKey = (options?: Options<GetAllPermissionsData>) => createQueryKey('getAllPermissions', options);

export const getAllPermissionsOptions = (options?: Options<GetAllPermissionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllPermissions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllPermissionsQueryKey(options)
    });
};

export const getAllPermissionsInfiniteQueryKey = (options?: Options<GetAllPermissionsData>): QueryKey<Options<GetAllPermissionsData>> => createQueryKey('getAllPermissions', options, true);

export const getAllPermissionsInfiniteOptions = (options?: Options<GetAllPermissionsData>) => {
    return infiniteQueryOptions<GetAllPermissionsResponse, AxiosError<DefaultError>, InfiniteData<GetAllPermissionsResponse>, QueryKey<Options<GetAllPermissionsData>>, number | Pick<QueryKey<Options<GetAllPermissionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllPermissionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllPermissions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllPermissionsInfiniteQueryKey(options)
    });
};

export const createPermissionQueryKey = (options: Options<CreatePermissionData>) => createQueryKey('createPermission', options);

export const createPermissionOptions = (options: Options<CreatePermissionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createPermission({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createPermissionQueryKey(options)
    });
};

export const createPermissionMutation = (options?: Partial<Options<CreatePermissionData>>): UseMutationOptions<CreatePermissionResponse, AxiosError<DefaultError>, Options<CreatePermissionData>> => {
    const mutationOptions: UseMutationOptions<CreatePermissionResponse, AxiosError<DefaultError>, Options<CreatePermissionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createPermission({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const generateUploadSignatureQueryKey = (options: Options<GenerateUploadSignatureData>) => createQueryKey('generateUploadSignature', options);

export const generateUploadSignatureOptions = (options: Options<GenerateUploadSignatureData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await generateUploadSignature({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: generateUploadSignatureQueryKey(options)
    });
};

export const generateUploadSignatureMutation = (options?: Partial<Options<GenerateUploadSignatureData>>): UseMutationOptions<GenerateUploadSignatureResponse, AxiosError<DefaultError>, Options<GenerateUploadSignatureData>> => {
    const mutationOptions: UseMutationOptions<GenerateUploadSignatureResponse, AxiosError<DefaultError>, Options<GenerateUploadSignatureData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await generateUploadSignature({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createAssetQueryKey = (options: Options<CreateAssetData>) => createQueryKey('createAsset', options);

export const createAssetOptions = (options: Options<CreateAssetData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createAsset({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createAssetQueryKey(options)
    });
};

export const createAssetMutation = (options?: Partial<Options<CreateAssetData>>): UseMutationOptions<CreateAssetResponse, AxiosError<DefaultError>, Options<CreateAssetData>> => {
    const mutationOptions: UseMutationOptions<CreateAssetResponse, AxiosError<DefaultError>, Options<CreateAssetData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createAsset({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const searchReportsQueryKey = (options?: Options<SearchReportsData>) => createQueryKey('searchReports', options);

export const searchReportsOptions = (options?: Options<SearchReportsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await searchReports({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: searchReportsQueryKey(options)
    });
};

export const searchReportsInfiniteQueryKey = (options?: Options<SearchReportsData>): QueryKey<Options<SearchReportsData>> => createQueryKey('searchReports', options, true);

export const searchReportsInfiniteOptions = (options?: Options<SearchReportsData>) => {
    return infiniteQueryOptions<SearchReportsResponse, AxiosError<DefaultError>, InfiniteData<SearchReportsResponse>, QueryKey<Options<SearchReportsData>>, number | Pick<QueryKey<Options<SearchReportsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<SearchReportsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await searchReports({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: searchReportsInfiniteQueryKey(options)
    });
};

export const createReportQueryKey = (options: Options<CreateReportData>) => createQueryKey('createReport', options);

export const createReportOptions = (options: Options<CreateReportData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createReport({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createReportQueryKey(options)
    });
};

export const createReportMutation = (options?: Partial<Options<CreateReportData>>): UseMutationOptions<CreateReportResponse, AxiosError<DefaultError>, Options<CreateReportData>> => {
    const mutationOptions: UseMutationOptions<CreateReportResponse, AxiosError<DefaultError>, Options<CreateReportData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createReport({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createPostQueryKey = (options: Options<CreatePostData>) => createQueryKey('createPost', options);

export const createPostOptions = (options: Options<CreatePostData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createPost({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createPostQueryKey(options)
    });
};

export const createPostMutation = (options?: Partial<Options<CreatePostData>>): UseMutationOptions<CreatePostResponse, AxiosError<DefaultError>, Options<CreatePostData>> => {
    const mutationOptions: UseMutationOptions<CreatePostResponse, AxiosError<DefaultError>, Options<CreatePostData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createPost({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const recordViewQueryKey = (options: Options<RecordViewData>) => createQueryKey('recordView', options);

export const recordViewOptions = (options: Options<RecordViewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await recordView({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: recordViewQueryKey(options)
    });
};

export const recordViewMutation = (options?: Partial<Options<RecordViewData>>): UseMutationOptions<RecordViewResponse, AxiosError<DefaultError>, Options<RecordViewData>> => {
    const mutationOptions: UseMutationOptions<RecordViewResponse, AxiosError<DefaultError>, Options<RecordViewData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await recordView({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getInteractionsByPostIdQueryKey = (options: Options<GetInteractionsByPostIdData>) => createQueryKey('getInteractionsByPostId', options);

export const getInteractionsByPostIdOptions = (options: Options<GetInteractionsByPostIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInteractionsByPostId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getInteractionsByPostIdQueryKey(options)
    });
};

export const createInteractionQueryKey = (options: Options<CreateInteractionData>) => createQueryKey('createInteraction', options);

export const createInteractionOptions = (options: Options<CreateInteractionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createInteraction({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createInteractionQueryKey(options)
    });
};

export const createInteractionMutation = (options?: Partial<Options<CreateInteractionData>>): UseMutationOptions<CreateInteractionResponse, AxiosError<DefaultError>, Options<CreateInteractionData>> => {
    const mutationOptions: UseMutationOptions<CreateInteractionResponse, AxiosError<DefaultError>, Options<CreateInteractionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createInteraction({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteBookmarkMutation = (options?: Partial<Options<DeleteBookmarkData>>): UseMutationOptions<DeleteBookmarkResponse, AxiosError<DefaultError>, Options<DeleteBookmarkData>> => {
    const mutationOptions: UseMutationOptions<DeleteBookmarkResponse, AxiosError<DefaultError>, Options<DeleteBookmarkData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteBookmark({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const isBookmarkedQueryKey = (options: Options<IsBookmarkedData>) => createQueryKey('isBookmarked', options);

export const isBookmarkedOptions = (options: Options<IsBookmarkedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await isBookmarked({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: isBookmarkedQueryKey(options)
    });
};

export const bookmarkPostQueryKey = (options: Options<BookmarkPostData>) => createQueryKey('bookmarkPost', options);

export const bookmarkPostOptions = (options: Options<BookmarkPostData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await bookmarkPost({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: bookmarkPostQueryKey(options)
    });
};

export const bookmarkPostMutation = (options?: Partial<Options<BookmarkPostData>>): UseMutationOptions<BookmarkPostResponse, AxiosError<DefaultError>, Options<BookmarkPostData>> => {
    const mutationOptions: UseMutationOptions<BookmarkPostResponse, AxiosError<DefaultError>, Options<BookmarkPostData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bookmarkPost({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllTagsQueryKey = (options?: Options<GetAllTagsData>) => createQueryKey('getAllTags', options);

export const getAllTagsOptions = (options?: Options<GetAllTagsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllTags({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllTagsQueryKey(options)
    });
};

export const getAllTagsInfiniteQueryKey = (options?: Options<GetAllTagsData>): QueryKey<Options<GetAllTagsData>> => createQueryKey('getAllTags', options, true);

export const getAllTagsInfiniteOptions = (options?: Options<GetAllTagsData>) => {
    return infiniteQueryOptions<GetAllTagsResponse, AxiosError<DefaultError>, InfiniteData<GetAllTagsResponse>, QueryKey<Options<GetAllTagsData>>, number | Pick<QueryKey<Options<GetAllTagsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllTagsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllTags({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllTagsInfiniteQueryKey(options)
    });
};

export const createTagQueryKey = (options: Options<CreateTagData>) => createQueryKey('createTag', options);

export const createTagOptions = (options: Options<CreateTagData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createTag({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createTagQueryKey(options)
    });
};

export const createTagMutation = (options?: Partial<Options<CreateTagData>>): UseMutationOptions<CreateTagResponse, AxiosError<DefaultError>, Options<CreateTagData>> => {
    const mutationOptions: UseMutationOptions<CreateTagResponse, AxiosError<DefaultError>, Options<CreateTagData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createTag({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const addTagsToPostQueryKey = (options: Options<AddTagsToPostData>) => createQueryKey('addTagsToPost', options);

export const addTagsToPostOptions = (options: Options<AddTagsToPostData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await addTagsToPost({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: addTagsToPostQueryKey(options)
    });
};

export const addTagsToPostMutation = (options?: Partial<Options<AddTagsToPostData>>): UseMutationOptions<AddTagsToPostResponse, AxiosError<DefaultError>, Options<AddTagsToPostData>> => {
    const mutationOptions: UseMutationOptions<AddTagsToPostResponse, AxiosError<DefaultError>, Options<AddTagsToPostData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await addTagsToPost({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPostCategoriesQueryKey = (options?: Options<GetPostCategoriesData>) => createQueryKey('getPostCategories', options);

export const getPostCategoriesOptions = (options?: Options<GetPostCategoriesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPostCategories({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPostCategoriesQueryKey(options)
    });
};

export const getPostCategoriesInfiniteQueryKey = (options?: Options<GetPostCategoriesData>): QueryKey<Options<GetPostCategoriesData>> => createQueryKey('getPostCategories', options, true);

export const getPostCategoriesInfiniteOptions = (options?: Options<GetPostCategoriesData>) => {
    return infiniteQueryOptions<GetPostCategoriesResponse, AxiosError<DefaultError>, InfiniteData<GetPostCategoriesResponse>, QueryKey<Options<GetPostCategoriesData>>, number | Pick<QueryKey<Options<GetPostCategoriesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetPostCategoriesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getPostCategories({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPostCategoriesInfiniteQueryKey(options)
    });
};

export const createPostCategoryQueryKey = (options: Options<CreatePostCategoryData>) => createQueryKey('createPostCategory', options);

export const createPostCategoryOptions = (options: Options<CreatePostCategoryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createPostCategory({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createPostCategoryQueryKey(options)
    });
};

export const createPostCategoryMutation = (options?: Partial<Options<CreatePostCategoryData>>): UseMutationOptions<CreatePostCategoryResponse, AxiosError<DefaultError>, Options<CreatePostCategoryData>> => {
    const mutationOptions: UseMutationOptions<CreatePostCategoryResponse, AxiosError<DefaultError>, Options<CreatePostCategoryData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createPostCategory({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const cleanupOldSoftDeletedNotificationsQueryKey = (options?: Options<CleanupOldSoftDeletedNotificationsData>) => createQueryKey('cleanupOldSoftDeletedNotifications', options);

export const cleanupOldSoftDeletedNotificationsOptions = (options?: Options<CleanupOldSoftDeletedNotificationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await cleanupOldSoftDeletedNotifications({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: cleanupOldSoftDeletedNotificationsQueryKey(options)
    });
};

export const cleanupOldSoftDeletedNotificationsMutation = (options?: Partial<Options<CleanupOldSoftDeletedNotificationsData>>): UseMutationOptions<CleanupOldSoftDeletedNotificationsResponse, AxiosError<DefaultError>, Options<CleanupOldSoftDeletedNotificationsData>> => {
    const mutationOptions: UseMutationOptions<CleanupOldSoftDeletedNotificationsResponse, AxiosError<DefaultError>, Options<CleanupOldSoftDeletedNotificationsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await cleanupOldSoftDeletedNotifications({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const unfollowMutation = (options?: Partial<Options<UnfollowData>>): UseMutationOptions<UnfollowResponse, AxiosError<DefaultError>, Options<UnfollowData>> => {
    const mutationOptions: UseMutationOptions<UnfollowResponse, AxiosError<DefaultError>, Options<UnfollowData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await unfollow({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const followQueryKey = (options: Options<FollowData>) => createQueryKey('follow', options);

export const followOptions = (options: Options<FollowData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await follow({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: followQueryKey(options)
    });
};

export const followMutation = (options?: Partial<Options<FollowData>>): UseMutationOptions<FollowResponse, AxiosError<DefaultError>, Options<FollowData>> => {
    const mutationOptions: UseMutationOptions<FollowResponse, AxiosError<DefaultError>, Options<FollowData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await follow({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createCommentQueryKey = (options: Options<CreateCommentData>) => createQueryKey('createComment', options);

export const createCommentOptions = (options: Options<CreateCommentData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createComment({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createCommentQueryKey(options)
    });
};

export const createCommentMutation = (options?: Partial<Options<CreateCommentData>>): UseMutationOptions<CreateCommentResponse, AxiosError<DefaultError>, Options<CreateCommentData>> => {
    const mutationOptions: UseMutationOptions<CreateCommentResponse, AxiosError<DefaultError>, Options<CreateCommentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createComment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getInteractionsQueryKey = (options: Options<GetInteractionsData>) => createQueryKey('getInteractions', options);

export const getInteractionsOptions = (options: Options<GetInteractionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getInteractions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getInteractionsQueryKey(options)
    });
};

export const createInteraction1QueryKey = (options: Options<CreateInteraction1Data>) => createQueryKey('createInteraction1', options);

export const createInteraction1Options = (options: Options<CreateInteraction1Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createInteraction1({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createInteraction1QueryKey(options)
    });
};

export const createInteraction1Mutation = (options?: Partial<Options<CreateInteraction1Data>>): UseMutationOptions<CreateInteraction1Response, AxiosError<DefaultError>, Options<CreateInteraction1Data>> => {
    const mutationOptions: UseMutationOptions<CreateInteraction1Response, AxiosError<DefaultError>, Options<CreateInteraction1Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createInteraction1({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const enableMaintenanceQueryKey = (options?: Options<EnableMaintenanceData>) => createQueryKey('enableMaintenance', options);

export const enableMaintenanceOptions = (options?: Options<EnableMaintenanceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await enableMaintenance({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: enableMaintenanceQueryKey(options)
    });
};

export const enableMaintenanceMutation = (options?: Partial<Options<EnableMaintenanceData>>): UseMutationOptions<EnableMaintenanceResponse, AxiosError<DefaultError>, Options<EnableMaintenanceData>> => {
    const mutationOptions: UseMutationOptions<EnableMaintenanceResponse, AxiosError<DefaultError>, Options<EnableMaintenanceData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await enableMaintenance({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const disableMaintenanceQueryKey = (options?: Options<DisableMaintenanceData>) => createQueryKey('disableMaintenance', options);

export const disableMaintenanceOptions = (options?: Options<DisableMaintenanceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await disableMaintenance({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: disableMaintenanceQueryKey(options)
    });
};

export const disableMaintenanceMutation = (options?: Partial<Options<DisableMaintenanceData>>): UseMutationOptions<DisableMaintenanceResponse, AxiosError<DefaultError>, Options<DisableMaintenanceData>> => {
    const mutationOptions: UseMutationOptions<DisableMaintenanceResponse, AxiosError<DefaultError>, Options<DisableMaintenanceData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await disableMaintenance({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllNotificationsQueryKey = (options?: Options<GetAllNotificationsData>) => createQueryKey('getAllNotifications', options);

export const getAllNotificationsOptions = (options?: Options<GetAllNotificationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllNotifications({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllNotificationsQueryKey(options)
    });
};

export const getAllNotificationsInfiniteQueryKey = (options?: Options<GetAllNotificationsData>): QueryKey<Options<GetAllNotificationsData>> => createQueryKey('getAllNotifications', options, true);

export const getAllNotificationsInfiniteOptions = (options?: Options<GetAllNotificationsData>) => {
    return infiniteQueryOptions<GetAllNotificationsResponse, AxiosError<DefaultError>, InfiniteData<GetAllNotificationsResponse>, QueryKey<Options<GetAllNotificationsData>>, number | Pick<QueryKey<Options<GetAllNotificationsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllNotificationsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllNotifications({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllNotificationsInfiniteQueryKey(options)
    });
};

export const createNotificationQueryKey = (options: Options<CreateNotificationData>) => createQueryKey('createNotification', options);

export const createNotificationOptions = (options: Options<CreateNotificationData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createNotification({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createNotificationQueryKey(options)
    });
};

export const createNotificationMutation = (options?: Partial<Options<CreateNotificationData>>): UseMutationOptions<CreateNotificationResponse, AxiosError<DefaultError>, Options<CreateNotificationData>> => {
    const mutationOptions: UseMutationOptions<CreateNotificationResponse, AxiosError<DefaultError>, Options<CreateNotificationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createNotification({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const createAdminNotificationsQueryKey = (options: Options<CreateAdminNotificationsData>) => createQueryKey('createAdminNotifications', options);

export const createAdminNotificationsOptions = (options: Options<CreateAdminNotificationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createAdminNotifications({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createAdminNotificationsQueryKey(options)
    });
};

export const createAdminNotificationsMutation = (options?: Partial<Options<CreateAdminNotificationsData>>): UseMutationOptions<CreateAdminNotificationsResponse, AxiosError<DefaultError>, Options<CreateAdminNotificationsData>> => {
    const mutationOptions: UseMutationOptions<CreateAdminNotificationsResponse, AxiosError<DefaultError>, Options<CreateAdminNotificationsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createAdminNotifications({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getAllLogEntriesQueryKey = (options?: Options<GetAllLogEntriesData>) => createQueryKey('getAllLogEntries', options);

export const getAllLogEntriesOptions = (options?: Options<GetAllLogEntriesData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllLogEntries({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllLogEntriesQueryKey(options)
    });
};

export const getAllLogEntriesInfiniteQueryKey = (options?: Options<GetAllLogEntriesData>): QueryKey<Options<GetAllLogEntriesData>> => createQueryKey('getAllLogEntries', options, true);

export const getAllLogEntriesInfiniteOptions = (options?: Options<GetAllLogEntriesData>) => {
    return infiniteQueryOptions<GetAllLogEntriesResponse, AxiosError<DefaultError>, InfiniteData<GetAllLogEntriesResponse>, QueryKey<Options<GetAllLogEntriesData>>, number | Pick<QueryKey<Options<GetAllLogEntriesData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllLogEntriesData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllLogEntries({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllLogEntriesInfiniteQueryKey(options)
    });
};

export const createLogEntryQueryKey = (options: Options<CreateLogEntryData>) => createQueryKey('createLogEntry', options);

export const createLogEntryOptions = (options: Options<CreateLogEntryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await createLogEntry({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: createLogEntryQueryKey(options)
    });
};

export const createLogEntryMutation = (options?: Partial<Options<CreateLogEntryData>>): UseMutationOptions<CreateLogEntryResponse, AxiosError<DefaultError>, Options<CreateLogEntryData>> => {
    const mutationOptions: UseMutationOptions<CreateLogEntryResponse, AxiosError<DefaultError>, Options<CreateLogEntryData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await createLogEntry({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deletePostCategoryMutation = (options?: Partial<Options<DeletePostCategoryData>>): UseMutationOptions<DeletePostCategoryResponse, AxiosError<DefaultError>, Options<DeletePostCategoryData>> => {
    const mutationOptions: UseMutationOptions<DeletePostCategoryResponse, AxiosError<DefaultError>, Options<DeletePostCategoryData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deletePostCategory({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const updatePostCategoryMutation = (options?: Partial<Options<UpdatePostCategoryData>>): UseMutationOptions<UpdatePostCategoryResponse, AxiosError<DefaultError>, Options<UpdatePostCategoryData>> => {
    const mutationOptions: UseMutationOptions<UpdatePostCategoryResponse, AxiosError<DefaultError>, Options<UpdatePostCategoryData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await updatePostCategory({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const unmarkNotificationAsReadMutation = (options?: Partial<Options<UnmarkNotificationAsReadData>>): UseMutationOptions<UnmarkNotificationAsReadResponse, AxiosError<DefaultError>, Options<UnmarkNotificationAsReadData>> => {
    const mutationOptions: UseMutationOptions<UnmarkNotificationAsReadResponse, AxiosError<DefaultError>, Options<UnmarkNotificationAsReadData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await unmarkNotificationAsRead({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const markNotificationAsReadMutation = (options?: Partial<Options<MarkNotificationAsReadData>>): UseMutationOptions<MarkNotificationAsReadResponse, AxiosError<DefaultError>, Options<MarkNotificationAsReadData>> => {
    const mutationOptions: UseMutationOptions<MarkNotificationAsReadResponse, AxiosError<DefaultError>, Options<MarkNotificationAsReadData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await markNotificationAsRead({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const unmarkAllNotificationsAsReadMutation = (options?: Partial<Options<UnmarkAllNotificationsAsReadData>>): UseMutationOptions<UnmarkAllNotificationsAsReadResponse, AxiosError<DefaultError>, Options<UnmarkAllNotificationsAsReadData>> => {
    const mutationOptions: UseMutationOptions<UnmarkAllNotificationsAsReadResponse, AxiosError<DefaultError>, Options<UnmarkAllNotificationsAsReadData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await unmarkAllNotificationsAsRead({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const markAllNotificationsAsReadMutation = (options?: Partial<Options<MarkAllNotificationsAsReadData>>): UseMutationOptions<MarkAllNotificationsAsReadResponse, AxiosError<DefaultError>, Options<MarkAllNotificationsAsReadData>> => {
    const mutationOptions: UseMutationOptions<MarkAllNotificationsAsReadResponse, AxiosError<DefaultError>, Options<MarkAllNotificationsAsReadData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await markAllNotificationsAsRead({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const unpinCommentMutation = (options?: Partial<Options<UnpinCommentData>>): UseMutationOptions<UnpinCommentResponse, AxiosError<DefaultError>, Options<UnpinCommentData>> => {
    const mutationOptions: UseMutationOptions<UnpinCommentResponse, AxiosError<DefaultError>, Options<UnpinCommentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await unpinComment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const pinCommentMutation = (options?: Partial<Options<PinCommentData>>): UseMutationOptions<PinCommentResponse, AxiosError<DefaultError>, Options<PinCommentData>> => {
    const mutationOptions: UseMutationOptions<PinCommentResponse, AxiosError<DefaultError>, Options<PinCommentData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await pinComment({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const markAsUnreadMutation = (options?: Partial<Options<MarkAsUnreadData>>): UseMutationOptions<MarkAsUnreadResponse, AxiosError<DefaultError>, Options<MarkAsUnreadData>> => {
    const mutationOptions: UseMutationOptions<MarkAsUnreadResponse, AxiosError<DefaultError>, Options<MarkAsUnreadData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await markAsUnread({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const markAsReadMutation = (options?: Partial<Options<MarkAsReadData>>): UseMutationOptions<MarkAsReadResponse, AxiosError<DefaultError>, Options<MarkAsReadData>> => {
    const mutationOptions: UseMutationOptions<MarkAsReadResponse, AxiosError<DefaultError>, Options<MarkAsReadData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await markAsRead({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const isUserExistsQueryKey = (options: Options<IsUserExistsData>) => createQueryKey('isUserExists', options);

export const isUserExistsOptions = (options: Options<IsUserExistsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await isUserExists({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: isUserExistsQueryKey(options)
    });
};

export const getUserSummaryQueryKey = (options: Options<GetUserSummaryData>) => createQueryKey('getUserSummary', options);

export const getUserSummaryOptions = (options: Options<GetUserSummaryData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserSummary({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserSummaryQueryKey(options)
    });
};

export const getUserIntroductionQueryKey = (options: Options<GetUserIntroductionData>) => createQueryKey('getUserIntroduction', options);

export const getUserIntroductionOptions = (options: Options<GetUserIntroductionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserIntroduction({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserIntroductionQueryKey(options)
    });
};

export const getRoleBySlugQueryKey = (options: Options<GetRoleBySlugData>) => createQueryKey('getRoleBySlug', options);

export const getRoleBySlugOptions = (options: Options<GetRoleBySlugData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getRoleBySlug({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getRoleBySlugQueryKey(options)
    });
};

export const getPermissionBySlugQueryKey = (options: Options<GetPermissionBySlugData>) => createQueryKey('getPermissionBySlug', options);

export const getPermissionBySlugOptions = (options: Options<GetPermissionBySlugData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPermissionBySlug({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPermissionBySlugQueryKey(options)
    });
};

export const deleteCurrentUserMutation = (options?: Partial<Options<DeleteCurrentUserData>>): UseMutationOptions<DeleteCurrentUserResponse, AxiosError<DefaultError>, Options<DeleteCurrentUserData>> => {
    const mutationOptions: UseMutationOptions<DeleteCurrentUserResponse, AxiosError<DefaultError>, Options<DeleteCurrentUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteCurrentUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getCurrentUserQueryKey = (options?: Options<GetCurrentUserData>) => createQueryKey('getCurrentUser', options);

export const getCurrentUserOptions = (options?: Options<GetCurrentUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCurrentUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCurrentUserQueryKey(options)
    });
};

export const isUserExistsByAuth0IdQueryKey = (options: Options<IsUserExistsByAuth0IdData>) => createQueryKey('isUserExistsByAuth0Id', options);

export const isUserExistsByAuth0IdOptions = (options: Options<IsUserExistsByAuth0IdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await isUserExistsByAuth0Id({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: isUserExistsByAuth0IdQueryKey(options)
    });
};

export const getVideoThumbnailUrlQueryKey = (options: Options<GetVideoThumbnailUrlData>) => createQueryKey('getVideoThumbnailUrl', options);

export const getVideoThumbnailUrlOptions = (options: Options<GetVideoThumbnailUrlData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVideoThumbnailUrl({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVideoThumbnailUrlQueryKey(options)
    });
};

export const getVideoPlaybackUrlQueryKey = (options: Options<GetVideoPlaybackUrlData>) => createQueryKey('getVideoPlaybackUrl', options);

export const getVideoPlaybackUrlOptions = (options: Options<GetVideoPlaybackUrlData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getVideoPlaybackUrl({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getVideoPlaybackUrlQueryKey(options)
    });
};

export const getAssetByIdQueryKey = (options: Options<GetAssetByIdData>) => createQueryKey('getAssetById', options);

export const getAssetByIdOptions = (options: Options<GetAssetByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAssetById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAssetByIdQueryKey(options)
    });
};

export const getAssetByPublicIdQueryKey = (options: Options<GetAssetByPublicIdData>) => createQueryKey('getAssetByPublicId', options);

export const getAssetByPublicIdOptions = (options: Options<GetAssetByPublicIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAssetByPublicId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAssetByPublicIdQueryKey(options)
    });
};

export const deleteReportMutation = (options?: Partial<Options<DeleteReportData>>): UseMutationOptions<DeleteReportResponse, AxiosError<DefaultError>, Options<DeleteReportData>> => {
    const mutationOptions: UseMutationOptions<DeleteReportResponse, AxiosError<DefaultError>, Options<DeleteReportData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteReport({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getReportByIdQueryKey = (options: Options<GetReportByIdData>) => createQueryKey('getReportById', options);

export const getReportByIdOptions = (options: Options<GetReportByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getReportById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getReportByIdQueryKey(options)
    });
};

export const getAllReportsQueryKey = (options?: Options<GetAllReportsData>) => createQueryKey('getAllReports', options);

export const getAllReportsOptions = (options?: Options<GetAllReportsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllReports({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllReportsQueryKey(options)
    });
};

export const getAllReportsInfiniteQueryKey = (options?: Options<GetAllReportsData>): QueryKey<Options<GetAllReportsData>> => createQueryKey('getAllReports', options, true);

export const getAllReportsInfiniteOptions = (options?: Options<GetAllReportsData>) => {
    return infiniteQueryOptions<GetAllReportsResponse, AxiosError<DefaultError>, InfiniteData<GetAllReportsResponse>, QueryKey<Options<GetAllReportsData>>, number | Pick<QueryKey<Options<GetAllReportsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllReportsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllReports({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllReportsInfiniteQueryKey(options)
    });
};

export const getTotalViewsQueryKey = (options: Options<GetTotalViewsData>) => createQueryKey('getTotalViews', options);

export const getTotalViewsOptions = (options: Options<GetTotalViewsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTotalViews({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTotalViewsQueryKey(options)
    });
};

export const hasMeInteractedQueryKey = (options: Options<HasMeInteractedData>) => createQueryKey('hasMeInteracted', options);

export const hasMeInteractedOptions = (options: Options<HasMeInteractedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await hasMeInteracted({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: hasMeInteractedQueryKey(options)
    });
};

export const getTotalViewsByUserIdQueryKey = (options: Options<GetTotalViewsByUserIdData>) => createQueryKey('getTotalViewsByUserId', options);

export const getTotalViewsByUserIdOptions = (options: Options<GetTotalViewsByUserIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTotalViewsByUserId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTotalViewsByUserIdQueryKey(options)
    });
};

export const getCountAllPostsByUserIdQueryKey = (options: Options<GetCountAllPostsByUserIdData>) => createQueryKey('getCountAllPostsByUserId', options);

export const getCountAllPostsByUserIdOptions = (options: Options<GetCountAllPostsByUserIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCountAllPostsByUserId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCountAllPostsByUserIdQueryKey(options)
    });
};

export const getAllPublicPostsByUserIdQueryKey = (options: Options<GetAllPublicPostsByUserIdData>) => createQueryKey('getAllPublicPostsByUserId', options);

export const getAllPublicPostsByUserIdOptions = (options: Options<GetAllPublicPostsByUserIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllPublicPostsByUserId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllPublicPostsByUserIdQueryKey(options)
    });
};

export const getAllPublicPostsByUserIdInfiniteQueryKey = (options: Options<GetAllPublicPostsByUserIdData>): QueryKey<Options<GetAllPublicPostsByUserIdData>> => createQueryKey('getAllPublicPostsByUserId', options, true);

export const getAllPublicPostsByUserIdInfiniteOptions = (options: Options<GetAllPublicPostsByUserIdData>) => {
    return infiniteQueryOptions<GetAllPublicPostsByUserIdResponse, AxiosError<DefaultError>, InfiniteData<GetAllPublicPostsByUserIdResponse>, QueryKey<Options<GetAllPublicPostsByUserIdData>>, number | Pick<QueryKey<Options<GetAllPublicPostsByUserIdData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllPublicPostsByUserIdData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllPublicPostsByUserId({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllPublicPostsByUserIdInfiniteQueryKey(options)
    });
};

export const getTagsWithCountsQueryKey = (options?: Options<GetTagsWithCountsData>) => createQueryKey('getTagsWithCounts', options);

export const getTagsWithCountsOptions = (options?: Options<GetTagsWithCountsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagsWithCounts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagsWithCountsQueryKey(options)
    });
};

export const getTagsWithCountsInfiniteQueryKey = (options?: Options<GetTagsWithCountsData>): QueryKey<Options<GetTagsWithCountsData>> => createQueryKey('getTagsWithCounts', options, true);

export const getTagsWithCountsInfiniteOptions = (options?: Options<GetTagsWithCountsData>) => {
    return infiniteQueryOptions<GetTagsWithCountsResponse, AxiosError<DefaultError>, InfiniteData<GetTagsWithCountsResponse>, QueryKey<Options<GetTagsWithCountsData>>, number | Pick<QueryKey<Options<GetTagsWithCountsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetTagsWithCountsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getTagsWithCounts({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagsWithCountsInfiniteQueryKey(options)
    });
};

export const getTagWithCountByIdQueryKey = (options: Options<GetTagWithCountByIdData>) => createQueryKey('getTagWithCountById', options);

export const getTagWithCountByIdOptions = (options: Options<GetTagWithCountByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagWithCountById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagWithCountByIdQueryKey(options)
    });
};

export const getTagWithCountBySlugQueryKey = (options: Options<GetTagWithCountBySlugData>) => createQueryKey('getTagWithCountBySlug', options);

export const getTagWithCountBySlugOptions = (options: Options<GetTagWithCountBySlugData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagWithCountBySlug({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagWithCountBySlugQueryKey(options)
    });
};

export const getTagWithCountByNameQueryKey = (options: Options<GetTagWithCountByNameData>) => createQueryKey('getTagWithCountByName', options);

export const getTagWithCountByNameOptions = (options: Options<GetTagWithCountByNameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagWithCountByName({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagWithCountByNameQueryKey(options)
    });
};

export const getTagNamesByPostIdQueryKey = (options: Options<GetTagNamesByPostIdData>) => createQueryKey('getTagNamesByPostId', options);

export const getTagNamesByPostIdOptions = (options: Options<GetTagNamesByPostIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagNamesByPostId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagNamesByPostIdQueryKey(options)
    });
};

export const getTagsByPostIdQueryKey = (options: Options<GetTagsByPostIdData>) => createQueryKey('getTagsByPostId', options);

export const getTagsByPostIdOptions = (options: Options<GetTagsByPostIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagsByPostId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagsByPostIdQueryKey(options)
    });
};

export const getAllTagsWithCountsQueryKey = (options?: Options<GetAllTagsWithCountsData>) => createQueryKey('getAllTagsWithCounts', options);

export const getAllTagsWithCountsOptions = (options?: Options<GetAllTagsWithCountsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllTagsWithCounts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllTagsWithCountsQueryKey(options)
    });
};

export const getAllPublicPostsQueryKey = (options?: Options<GetAllPublicPostsData>) => createQueryKey('getAllPublicPosts', options);

export const getAllPublicPostsOptions = (options?: Options<GetAllPublicPostsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllPublicPosts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllPublicPostsQueryKey(options)
    });
};

export const getMeAllPostsQueryKey = (options?: Options<GetMeAllPostsData>) => createQueryKey('getMeAllPosts', options);

export const getMeAllPostsOptions = (options?: Options<GetMeAllPostsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMeAllPosts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMeAllPostsQueryKey(options)
    });
};

export const getPostCategoryByNameQueryKey = (options: Options<GetPostCategoryByNameData>) => createQueryKey('getPostCategoryByName', options);

export const getPostCategoryByNameOptions = (options: Options<GetPostCategoryByNameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPostCategoryByName({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPostCategoryByNameQueryKey(options)
    });
};

export const getCategoriesWithCountsQueryKey = (options?: Options<GetCategoriesWithCountsData>) => createQueryKey('getCategoriesWithCounts', options);

export const getCategoriesWithCountsOptions = (options?: Options<GetCategoriesWithCountsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCategoriesWithCounts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCategoriesWithCountsQueryKey(options)
    });
};

export const getCategoriesWithCountsInfiniteQueryKey = (options?: Options<GetCategoriesWithCountsData>): QueryKey<Options<GetCategoriesWithCountsData>> => createQueryKey('getCategoriesWithCounts', options, true);

export const getCategoriesWithCountsInfiniteOptions = (options?: Options<GetCategoriesWithCountsData>) => {
    return infiniteQueryOptions<GetCategoriesWithCountsResponse, AxiosError<DefaultError>, InfiniteData<GetCategoriesWithCountsResponse>, QueryKey<Options<GetCategoriesWithCountsData>>, number | Pick<QueryKey<Options<GetCategoriesWithCountsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetCategoriesWithCountsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getCategoriesWithCounts({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCategoriesWithCountsInfiniteQueryKey(options)
    });
};

export const getCategoryWithCountByNameQueryKey = (options: Options<GetCategoryWithCountByNameData>) => createQueryKey('getCategoryWithCountByName', options);

export const getCategoryWithCountByNameOptions = (options: Options<GetCategoryWithCountByNameData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCategoryWithCountByName({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCategoryWithCountByNameQueryKey(options)
    });
};

export const getCategoryWithCountByIdQueryKey = (options: Options<GetCategoryWithCountByIdData>) => createQueryKey('getCategoryWithCountById', options);

export const getCategoryWithCountByIdOptions = (options: Options<GetCategoryWithCountByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCategoryWithCountById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCategoryWithCountByIdQueryKey(options)
    });
};

export const getPostCategoryByIdQueryKey = (options: Options<GetPostCategoryByIdData>) => createQueryKey('getPostCategoryById', options);

export const getPostCategoryByIdOptions = (options: Options<GetPostCategoryByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPostCategoryById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPostCategoryByIdQueryKey(options)
    });
};

export const getAllCategoriesWithCountsQueryKey = (options?: Options<GetAllCategoriesWithCountsData>) => createQueryKey('getAllCategoriesWithCounts', options);

export const getAllCategoriesWithCountsOptions = (options?: Options<GetAllCategoriesWithCountsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllCategoriesWithCounts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllCategoriesWithCountsQueryKey(options)
    });
};

export const getNotificationByIdQueryKey = (options: Options<GetNotificationByIdData>) => createQueryKey('getNotificationById', options);

export const getNotificationByIdOptions = (options: Options<GetNotificationByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNotificationById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNotificationByIdQueryKey(options)
    });
};

export const getNotificationStatisticsQueryKey = (options?: Options<GetNotificationStatisticsData>) => createQueryKey('getNotificationStatistics', options);

export const getNotificationStatisticsOptions = (options?: Options<GetNotificationStatisticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNotificationStatistics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNotificationStatisticsQueryKey(options)
    });
};

export const getMyNotificationsQueryKey = (options?: Options<GetMyNotificationsData>) => createQueryKey('getMyNotifications', options);

export const getMyNotificationsOptions = (options?: Options<GetMyNotificationsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMyNotifications({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMyNotificationsQueryKey(options)
    });
};

export const getMyNotificationsInfiniteQueryKey = (options?: Options<GetMyNotificationsData>): QueryKey<Options<GetMyNotificationsData>> => createQueryKey('getMyNotifications', options, true);

export const getMyNotificationsInfiniteOptions = (options?: Options<GetMyNotificationsData>) => {
    return infiniteQueryOptions<GetMyNotificationsResponse, AxiosError<DefaultError>, InfiniteData<GetMyNotificationsResponse>, QueryKey<Options<GetMyNotificationsData>>, number | Pick<QueryKey<Options<GetMyNotificationsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetMyNotificationsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getMyNotifications({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMyNotificationsInfiniteQueryKey(options)
    });
};

export const getHistoriesByUserIdQueryKey = (options: Options<GetHistoriesByUserIdData>) => createQueryKey('getHistoriesByUserId', options);

export const getHistoriesByUserIdOptions = (options: Options<GetHistoriesByUserIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getHistoriesByUserId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getHistoriesByUserIdQueryKey(options)
    });
};

export const getHistoriesByUserIdInfiniteQueryKey = (options: Options<GetHistoriesByUserIdData>): QueryKey<Options<GetHistoriesByUserIdData>> => createQueryKey('getHistoriesByUserId', options, true);

export const getHistoriesByUserIdInfiniteOptions = (options: Options<GetHistoriesByUserIdData>) => {
    return infiniteQueryOptions<GetHistoriesByUserIdResponse, AxiosError<DefaultError>, InfiniteData<GetHistoriesByUserIdResponse>, QueryKey<Options<GetHistoriesByUserIdData>>, number | Pick<QueryKey<Options<GetHistoriesByUserIdData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetHistoriesByUserIdData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getHistoriesByUserId({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getHistoriesByUserIdInfiniteQueryKey(options)
    });
};

export const getHistoriesForMeQueryKey = (options?: Options<GetHistoriesForMeData>) => createQueryKey('getHistoriesForMe', options);

export const getHistoriesForMeOptions = (options?: Options<GetHistoriesForMeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getHistoriesForMe({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getHistoriesForMeQueryKey(options)
    });
};

export const getHistoriesForMeInfiniteQueryKey = (options?: Options<GetHistoriesForMeData>): QueryKey<Options<GetHistoriesForMeData>> => createQueryKey('getHistoriesForMe', options, true);

export const getHistoriesForMeInfiniteOptions = (options?: Options<GetHistoriesForMeData>) => {
    return infiniteQueryOptions<GetHistoriesForMeResponse, AxiosError<DefaultError>, InfiniteData<GetHistoriesForMeResponse>, QueryKey<Options<GetHistoriesForMeData>>, number | Pick<QueryKey<Options<GetHistoriesForMeData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetHistoriesForMeData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getHistoriesForMe({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getHistoriesForMeInfiniteQueryKey(options)
    });
};

export const getOverviewQueryKey = (options: Options<GetOverviewData>) => createQueryKey('getOverview', options);

export const getOverviewOptions = (options: Options<GetOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getOverviewQueryKey(options)
    });
};

export const getFollowingByUserIdQueryKey = (options: Options<GetFollowingByUserIdData>) => createQueryKey('getFollowingByUserId', options);

export const getFollowingByUserIdOptions = (options: Options<GetFollowingByUserIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFollowingByUserId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFollowingByUserIdQueryKey(options)
    });
};

export const getFollowingByUserIdInfiniteQueryKey = (options: Options<GetFollowingByUserIdData>): QueryKey<Options<GetFollowingByUserIdData>> => createQueryKey('getFollowingByUserId', options, true);

export const getFollowingByUserIdInfiniteOptions = (options: Options<GetFollowingByUserIdData>) => {
    return infiniteQueryOptions<GetFollowingByUserIdResponse, AxiosError<DefaultError>, InfiniteData<GetFollowingByUserIdResponse>, QueryKey<Options<GetFollowingByUserIdData>>, number | Pick<QueryKey<Options<GetFollowingByUserIdData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetFollowingByUserIdData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getFollowingByUserId({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFollowingByUserIdInfiniteQueryKey(options)
    });
};

export const getFollowersByUserIdQueryKey = (options: Options<GetFollowersByUserIdData>) => createQueryKey('getFollowersByUserId', options);

export const getFollowersByUserIdOptions = (options: Options<GetFollowersByUserIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFollowersByUserId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFollowersByUserIdQueryKey(options)
    });
};

export const getFollowersByUserIdInfiniteQueryKey = (options: Options<GetFollowersByUserIdData>): QueryKey<Options<GetFollowersByUserIdData>> => createQueryKey('getFollowersByUserId', options, true);

export const getFollowersByUserIdInfiniteOptions = (options: Options<GetFollowersByUserIdData>) => {
    return infiniteQueryOptions<GetFollowersByUserIdResponse, AxiosError<DefaultError>, InfiniteData<GetFollowersByUserIdResponse>, QueryKey<Options<GetFollowersByUserIdData>>, number | Pick<QueryKey<Options<GetFollowersByUserIdData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetFollowersByUserIdData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getFollowersByUserId({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFollowersByUserIdInfiniteQueryKey(options)
    });
};

export const getMyFollowingQueryKey = (options?: Options<GetMyFollowingData>) => createQueryKey('getMyFollowing', options);

export const getMyFollowingOptions = (options?: Options<GetMyFollowingData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMyFollowing({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMyFollowingQueryKey(options)
    });
};

export const getMyFollowingInfiniteQueryKey = (options?: Options<GetMyFollowingData>): QueryKey<Options<GetMyFollowingData>> => createQueryKey('getMyFollowing', options, true);

export const getMyFollowingInfiniteOptions = (options?: Options<GetMyFollowingData>) => {
    return infiniteQueryOptions<GetMyFollowingResponse, AxiosError<DefaultError>, InfiniteData<GetMyFollowingResponse>, QueryKey<Options<GetMyFollowingData>>, number | Pick<QueryKey<Options<GetMyFollowingData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetMyFollowingData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getMyFollowing({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMyFollowingInfiniteQueryKey(options)
    });
};

export const getMyFollowersQueryKey = (options?: Options<GetMyFollowersData>) => createQueryKey('getMyFollowers', options);

export const getMyFollowersOptions = (options?: Options<GetMyFollowersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getMyFollowers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMyFollowersQueryKey(options)
    });
};

export const getMyFollowersInfiniteQueryKey = (options?: Options<GetMyFollowersData>): QueryKey<Options<GetMyFollowersData>> => createQueryKey('getMyFollowers', options, true);

export const getMyFollowersInfiniteOptions = (options?: Options<GetMyFollowersData>) => {
    return infiniteQueryOptions<GetMyFollowersResponse, AxiosError<DefaultError>, InfiniteData<GetMyFollowersResponse>, QueryKey<Options<GetMyFollowersData>>, number | Pick<QueryKey<Options<GetMyFollowersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetMyFollowersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getMyFollowers({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getMyFollowersInfiniteQueryKey(options)
    });
};

export const isFriendQueryKey = (options: Options<IsFriendData>) => createQueryKey('isFriend', options);

export const isFriendOptions = (options: Options<IsFriendData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await isFriend({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: isFriendQueryKey(options)
    });
};

export const getFeedQueryKey = (options?: Options<GetFeedData>) => createQueryKey('getFeed', options);

export const getFeedOptions = (options?: Options<GetFeedData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFeed({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFeedQueryKey(options)
    });
};

export const getFeedInfiniteQueryKey = (options?: Options<GetFeedData>): QueryKey<Options<GetFeedData>> => createQueryKey('getFeed', options, true);

export const getFeedInfiniteOptions = (options?: Options<GetFeedData>) => {
    return infiniteQueryOptions<GetFeedResponse, AxiosError<DefaultError>, InfiniteData<GetFeedResponse>, QueryKey<Options<GetFeedData>>, number | Pick<QueryKey<Options<GetFeedData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetFeedData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getFeed({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFeedInfiniteQueryKey(options)
    });
};

export const getFeedByUserIdQueryKey = (options: Options<GetFeedByUserIdData>) => createQueryKey('getFeedByUserId', options);

export const getFeedByUserIdOptions = (options: Options<GetFeedByUserIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFeedByUserId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFeedByUserIdQueryKey(options)
    });
};

export const getFeedByUserIdInfiniteQueryKey = (options: Options<GetFeedByUserIdData>): QueryKey<Options<GetFeedByUserIdData>> => createQueryKey('getFeedByUserId', options, true);

export const getFeedByUserIdInfiniteOptions = (options: Options<GetFeedByUserIdData>) => {
    return infiniteQueryOptions<GetFeedByUserIdResponse, AxiosError<DefaultError>, InfiniteData<GetFeedByUserIdResponse>, QueryKey<Options<GetFeedByUserIdData>>, number | Pick<QueryKey<Options<GetFeedByUserIdData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetFeedByUserIdData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getFeedByUserId({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFeedByUserIdInfiniteQueryKey(options)
    });
};

export const getFeed1QueryKey = (options: Options<GetFeed1Data>) => createQueryKey('getFeed1', options);

export const getFeed1Options = (options: Options<GetFeed1Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getFeed1({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getFeed1QueryKey(options)
    });
};

export const getAllCommentsByPostIdQueryKey = (options: Options<GetAllCommentsByPostIdData>) => createQueryKey('getAllCommentsByPostId', options);

export const getAllCommentsByPostIdOptions = (options: Options<GetAllCommentsByPostIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllCommentsByPostId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllCommentsByPostIdQueryKey(options)
    });
};

export const getAllCommentsByPostIdInfiniteQueryKey = (options: Options<GetAllCommentsByPostIdData>): QueryKey<Options<GetAllCommentsByPostIdData>> => createQueryKey('getAllCommentsByPostId', options, true);

export const getAllCommentsByPostIdInfiniteOptions = (options: Options<GetAllCommentsByPostIdData>) => {
    return infiniteQueryOptions<GetAllCommentsByPostIdResponse, AxiosError<DefaultError>, InfiniteData<GetAllCommentsByPostIdResponse>, QueryKey<Options<GetAllCommentsByPostIdData>>, number | Pick<QueryKey<Options<GetAllCommentsByPostIdData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllCommentsByPostIdData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllCommentsByPostId({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllCommentsByPostIdInfiniteQueryKey(options)
    });
};

export const getModerationOverviewQueryKey = (options?: Options<GetModerationOverviewData>) => createQueryKey('getModerationOverview', options);

export const getModerationOverviewOptions = (options?: Options<GetModerationOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getModerationOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getModerationOverviewQueryKey(options)
    });
};

export const getUserModerationOverviewQueryKey = (options?: Options<GetUserModerationOverviewData>) => createQueryKey('getUserModerationOverview', options);

export const getUserModerationOverviewOptions = (options?: Options<GetUserModerationOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserModerationOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserModerationOverviewQueryKey(options)
    });
};

export const getPostModerationOverviewQueryKey = (options?: Options<GetPostModerationOverviewData>) => createQueryKey('getPostModerationOverview', options);

export const getPostModerationOverviewOptions = (options?: Options<GetPostModerationOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPostModerationOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPostModerationOverviewQueryKey(options)
    });
};

export const getCommentModerationOverviewQueryKey = (options?: Options<GetCommentModerationOverviewData>) => createQueryKey('getCommentModerationOverview', options);

export const getCommentModerationOverviewOptions = (options?: Options<GetCommentModerationOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCommentModerationOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCommentModerationOverviewQueryKey(options)
    });
};

export const getDailyPendingAndResolvedReportsQueryKey = (options: Options<GetDailyPendingAndResolvedReportsData>) => createQueryKey('getDailyPendingAndResolvedReports', options);

export const getDailyPendingAndResolvedReportsOptions = (options: Options<GetDailyPendingAndResolvedReportsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDailyPendingAndResolvedReports({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDailyPendingAndResolvedReportsQueryKey(options)
    });
};

export const getLogOverviewQueryKey = (options?: Options<GetLogOverviewData>) => createQueryKey('getLogOverview', options);

export const getLogOverviewOptions = (options?: Options<GetLogOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLogOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLogOverviewQueryKey(options)
    });
};

export const getDailyErrorLogsQueryKey = (options?: Options<GetDailyErrorLogsData>) => createQueryKey('getDailyErrorLogs', options);

export const getDailyErrorLogsOptions = (options?: Options<GetDailyErrorLogsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDailyErrorLogs({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDailyErrorLogsQueryKey(options)
    });
};

export const getDailyLogsBySeverityQueryKey = (options?: Options<GetDailyLogsBySeverityData>) => createQueryKey('getDailyLogsBySeverity', options);

export const getDailyLogsBySeverityOptions = (options?: Options<GetDailyLogsBySeverityData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDailyLogsBySeverity({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDailyLogsBySeverityQueryKey(options)
    });
};

export const getNotificationTrendsQueryKey = (options?: Options<GetNotificationTrendsData>) => createQueryKey('getNotificationTrends', options);

export const getNotificationTrendsOptions = (options?: Options<GetNotificationTrendsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNotificationTrends({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNotificationTrendsQueryKey(options)
    });
};

export const getAdminNotificationOverviewQueryKey = (options?: Options<GetAdminNotificationOverviewData>) => createQueryKey('getAdminNotificationOverview', options);

export const getAdminNotificationOverviewOptions = (options?: Options<GetAdminNotificationOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAdminNotificationOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAdminNotificationOverviewQueryKey(options)
    });
};

export const getNotificationsByTypeQueryKey = (options?: Options<GetNotificationsByTypeData>) => createQueryKey('getNotificationsByType', options);

export const getNotificationsByTypeOptions = (options?: Options<GetNotificationsByTypeData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNotificationsByType({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNotificationsByTypeQueryKey(options)
    });
};

export const getNotificationsBySeverityQueryKey = (options?: Options<GetNotificationsBySeverityData>) => createQueryKey('getNotificationsBySeverity', options);

export const getNotificationsBySeverityOptions = (options?: Options<GetNotificationsBySeverityData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNotificationsBySeverity({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNotificationsBySeverityQueryKey(options)
    });
};

export const getAllUsersQueryKey = (options?: Options<GetAllUsersData>) => createQueryKey('getAllUsers', options);

export const getAllUsersOptions = (options?: Options<GetAllUsersData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllUsers({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllUsersQueryKey(options)
    });
};

export const getAllUsersInfiniteQueryKey = (options?: Options<GetAllUsersData>): QueryKey<Options<GetAllUsersData>> => createQueryKey('getAllUsers', options, true);

export const getAllUsersInfiniteOptions = (options?: Options<GetAllUsersData>) => {
    return infiniteQueryOptions<GetAllUsersResponse, AxiosError<DefaultError>, InfiniteData<GetAllUsersResponse>, QueryKey<Options<GetAllUsersData>>, number | Pick<QueryKey<Options<GetAllUsersData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllUsersData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllUsers({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllUsersInfiniteQueryKey(options)
    });
};

export const deleteUserMutation = (options?: Partial<Options<DeleteUserData>>): UseMutationOptions<DeleteUserResponse, AxiosError<DefaultError>, Options<DeleteUserData>> => {
    const mutationOptions: UseMutationOptions<DeleteUserResponse, AxiosError<DefaultError>, Options<DeleteUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getUserQueryKey = (options: Options<GetUserData>) => createQueryKey('getUser', options);

export const getUserOptions = (options: Options<GetUserData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUser({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserQueryKey(options)
    });
};

export const getAllUserIntroductionsQueryKey = (options?: Options<GetAllUserIntroductionsData>) => createQueryKey('getAllUserIntroductions', options);

export const getAllUserIntroductionsOptions = (options?: Options<GetAllUserIntroductionsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllUserIntroductions({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllUserIntroductionsQueryKey(options)
    });
};

export const getAllUserIntroductionsInfiniteQueryKey = (options?: Options<GetAllUserIntroductionsData>): QueryKey<Options<GetAllUserIntroductionsData>> => createQueryKey('getAllUserIntroductions', options, true);

export const getAllUserIntroductionsInfiniteOptions = (options?: Options<GetAllUserIntroductionsData>) => {
    return infiniteQueryOptions<GetAllUserIntroductionsResponse, AxiosError<DefaultError>, InfiniteData<GetAllUserIntroductionsResponse>, QueryKey<Options<GetAllUserIntroductionsData>>, number | Pick<QueryKey<Options<GetAllUserIntroductionsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllUserIntroductionsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllUserIntroductions({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllUserIntroductionsInfiniteQueryKey(options)
    });
};

export const getSystemStatusQueryKey = (options?: Options<GetSystemStatusData>) => createQueryKey('getSystemStatus', options);

export const getSystemStatusOptions = (options?: Options<GetSystemStatusData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getSystemStatus({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getSystemStatusQueryKey(options)
    });
};

export const getStatusMaintenanceQueryKey = (options?: Options<GetStatusMaintenanceData>) => createQueryKey('getStatusMaintenance', options);

export const getStatusMaintenanceOptions = (options?: Options<GetStatusMaintenanceData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getStatusMaintenance({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getStatusMaintenanceQueryKey(options)
    });
};

export const getDatabaseSchemaQueryKey = (options?: Options<GetDatabaseSchemaData>) => createQueryKey('getDatabaseSchema', options);

export const getDatabaseSchemaOptions = (options?: Options<GetDatabaseSchemaData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDatabaseSchema({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDatabaseSchemaQueryKey(options)
    });
};

export const getAllPostsForAdminQueryKey = (options?: Options<GetAllPostsForAdminData>) => createQueryKey('getAllPostsForAdmin', options);

export const getAllPostsForAdminOptions = (options?: Options<GetAllPostsForAdminData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllPostsForAdmin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllPostsForAdminQueryKey(options)
    });
};

export const getAllPostsForAdminInfiniteQueryKey = (options?: Options<GetAllPostsForAdminData>): QueryKey<Options<GetAllPostsForAdminData>> => createQueryKey('getAllPostsForAdmin', options, true);

export const getAllPostsForAdminInfiniteOptions = (options?: Options<GetAllPostsForAdminData>) => {
    return infiniteQueryOptions<GetAllPostsForAdminResponse, AxiosError<DefaultError>, InfiniteData<GetAllPostsForAdminResponse>, QueryKey<Options<GetAllPostsForAdminData>>, number | Pick<QueryKey<Options<GetAllPostsForAdminData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllPostsForAdminData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllPostsForAdmin({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllPostsForAdminInfiniteQueryKey(options)
    });
};

export const deletePost1Mutation = (options?: Partial<Options<DeletePost1Data>>): UseMutationOptions<DeletePost1Response, AxiosError<DefaultError>, Options<DeletePost1Data>> => {
    const mutationOptions: UseMutationOptions<DeletePost1Response, AxiosError<DefaultError>, Options<DeletePost1Data>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deletePost1({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getPostByIdForAdminQueryKey = (options: Options<GetPostByIdForAdminData>) => createQueryKey('getPostByIdForAdmin', options);

export const getPostByIdForAdminOptions = (options: Options<GetPostByIdForAdminData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPostByIdForAdmin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPostByIdForAdminQueryKey(options)
    });
};

export const getAllPostWithDetailsForAdminQueryKey = (options?: Options<GetAllPostWithDetailsForAdminData>) => createQueryKey('getAllPostWithDetailsForAdmin', options);

export const getAllPostWithDetailsForAdminOptions = (options?: Options<GetAllPostWithDetailsForAdminData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllPostWithDetailsForAdmin({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllPostWithDetailsForAdminQueryKey(options)
    });
};

export const getAllPostWithDetailsForAdminInfiniteQueryKey = (options?: Options<GetAllPostWithDetailsForAdminData>): QueryKey<Options<GetAllPostWithDetailsForAdminData>> => createQueryKey('getAllPostWithDetailsForAdmin', options, true);

export const getAllPostWithDetailsForAdminInfiniteOptions = (options?: Options<GetAllPostWithDetailsForAdminData>) => {
    return infiniteQueryOptions<GetAllPostWithDetailsForAdminResponse, AxiosError<DefaultError>, InfiniteData<GetAllPostWithDetailsForAdminResponse>, QueryKey<Options<GetAllPostWithDetailsForAdminData>>, number | Pick<QueryKey<Options<GetAllPostWithDetailsForAdminData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllPostWithDetailsForAdminData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllPostWithDetailsForAdmin({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllPostWithDetailsForAdminInfiniteQueryKey(options)
    });
};

export const deleteNotificationMutation = (options?: Partial<Options<DeleteNotificationData>>): UseMutationOptions<DeleteNotificationResponse, AxiosError<DefaultError>, Options<DeleteNotificationData>> => {
    const mutationOptions: UseMutationOptions<DeleteNotificationResponse, AxiosError<DefaultError>, Options<DeleteNotificationData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteNotification({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const getNotificationById1QueryKey = (options: Options<GetNotificationById1Data>) => createQueryKey('getNotificationById1', options);

export const getNotificationById1Options = (options: Options<GetNotificationById1Data>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getNotificationById1({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getNotificationById1QueryKey(options)
    });
};

export const getAllNotificationByRecipientIdQueryKey = (options: Options<GetAllNotificationByRecipientIdData>) => createQueryKey('getAllNotificationByRecipientId', options);

export const getAllNotificationByRecipientIdOptions = (options: Options<GetAllNotificationByRecipientIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllNotificationByRecipientId({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllNotificationByRecipientIdQueryKey(options)
    });
};

export const getAllNotificationByRecipientIdInfiniteQueryKey = (options: Options<GetAllNotificationByRecipientIdData>): QueryKey<Options<GetAllNotificationByRecipientIdData>> => createQueryKey('getAllNotificationByRecipientId', options, true);

export const getAllNotificationByRecipientIdInfiniteOptions = (options: Options<GetAllNotificationByRecipientIdData>) => {
    return infiniteQueryOptions<GetAllNotificationByRecipientIdResponse, AxiosError<DefaultError>, InfiniteData<GetAllNotificationByRecipientIdResponse>, QueryKey<Options<GetAllNotificationByRecipientIdData>>, number | Pick<QueryKey<Options<GetAllNotificationByRecipientIdData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllNotificationByRecipientIdData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllNotificationByRecipientId({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllNotificationByRecipientIdInfiniteQueryKey(options)
    });
};

export const getLogEntryByIdQueryKey = (options: Options<GetLogEntryByIdData>) => createQueryKey('getLogEntryById', options);

export const getLogEntryByIdOptions = (options: Options<GetLogEntryByIdData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getLogEntryById({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getLogEntryByIdQueryKey(options)
    });
};

export const getAllCommentsQueryKey = (options?: Options<GetAllCommentsData>) => createQueryKey('getAllComments', options);

export const getAllCommentsOptions = (options?: Options<GetAllCommentsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllComments({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllCommentsQueryKey(options)
    });
};

export const getAllCommentsInfiniteQueryKey = (options?: Options<GetAllCommentsData>): QueryKey<Options<GetAllCommentsData>> => createQueryKey('getAllComments', options, true);

export const getAllCommentsInfiniteOptions = (options?: Options<GetAllCommentsData>) => {
    return infiniteQueryOptions<GetAllCommentsResponse, AxiosError<DefaultError>, InfiniteData<GetAllCommentsResponse>, QueryKey<Options<GetAllCommentsData>>, number | Pick<QueryKey<Options<GetAllCommentsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllCommentsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllComments({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllCommentsInfiniteQueryKey(options)
    });
};

export const getAllCommentsWithPostDetailsQueryKey = (options?: Options<GetAllCommentsWithPostDetailsData>) => createQueryKey('getAllCommentsWithPostDetails', options);

export const getAllCommentsWithPostDetailsOptions = (options?: Options<GetAllCommentsWithPostDetailsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllCommentsWithPostDetails({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllCommentsWithPostDetailsQueryKey(options)
    });
};

export const getAllCommentsWithPostDetailsInfiniteQueryKey = (options?: Options<GetAllCommentsWithPostDetailsData>): QueryKey<Options<GetAllCommentsWithPostDetailsData>> => createQueryKey('getAllCommentsWithPostDetails', options, true);

export const getAllCommentsWithPostDetailsInfiniteOptions = (options?: Options<GetAllCommentsWithPostDetailsData>) => {
    return infiniteQueryOptions<GetAllCommentsWithPostDetailsResponse, AxiosError<DefaultError>, InfiniteData<GetAllCommentsWithPostDetailsResponse>, QueryKey<Options<GetAllCommentsWithPostDetailsData>>, number | Pick<QueryKey<Options<GetAllCommentsWithPostDetailsData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllCommentsWithPostDetailsData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAllCommentsWithPostDetails({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllCommentsWithPostDetailsInfiniteQueryKey(options)
    });
};

export const getUserAnalyticsOverviewQueryKey = (options?: Options<GetUserAnalyticsOverviewData>) => createQueryKey('getUserAnalyticsOverview', options);

export const getUserAnalyticsOverviewOptions = (options?: Options<GetUserAnalyticsOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUserAnalyticsOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUserAnalyticsOverviewQueryKey(options)
    });
};

export const getDailyUserCountsQueryKey = (options?: Options<GetDailyUserCountsData>) => createQueryKey('getDailyUserCounts', options);

export const getDailyUserCountsOptions = (options?: Options<GetDailyUserCountsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDailyUserCounts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDailyUserCountsQueryKey(options)
    });
};

export const getTagAnalyticsOverviewQueryKey = (options?: Options<GetTagAnalyticsOverviewData>) => createQueryKey('getTagAnalyticsOverview', options);

export const getTagAnalyticsOverviewOptions = (options?: Options<GetTagAnalyticsOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagAnalyticsOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagAnalyticsOverviewQueryKey(options)
    });
};

export const getTagDistributionQueryKey = (options: Options<GetTagDistributionData>) => createQueryKey('getTagDistribution', options);

export const getTagDistributionOptions = (options: Options<GetTagDistributionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getTagDistribution({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getTagDistributionQueryKey(options)
    });
};

export const getDailyTagCountsQueryKey = (options?: Options<GetDailyTagCountsData>) => createQueryKey('getDailyTagCounts', options);

export const getDailyTagCountsOptions = (options?: Options<GetDailyTagCountsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDailyTagCounts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDailyTagCountsQueryKey(options)
    });
};

export const getPostAnalyticsQueryKey = (options?: Options<GetPostAnalyticsData>) => createQueryKey('getPostAnalytics', options);

export const getPostAnalyticsOptions = (options?: Options<GetPostAnalyticsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPostAnalytics({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPostAnalyticsQueryKey(options)
    });
};

export const getDailyPostCountQueryKey = (options: Options<GetDailyPostCountData>) => createQueryKey('getDailyPostCount', options);

export const getDailyPostCountOptions = (options: Options<GetDailyPostCountData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDailyPostCount({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDailyPostCountQueryKey(options)
    });
};

export const getUsersPerDayQueryKey = (options?: Options<GetUsersPerDayData>) => createQueryKey('getUsersPerDay', options);

export const getUsersPerDayOptions = (options?: Options<GetUsersPerDayData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getUsersPerDay({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getUsersPerDayQueryKey(options)
    });
};

export const getPostsPerDayQueryKey = (options?: Options<GetPostsPerDayData>) => createQueryKey('getPostsPerDay', options);

export const getPostsPerDayOptions = (options?: Options<GetPostsPerDayData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getPostsPerDay({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getPostsPerDayQueryKey(options)
    });
};

export const getDashboardOverviewQueryKey = (options?: Options<GetDashboardOverviewData>) => createQueryKey('getDashboardOverview', options);

export const getDashboardOverviewOptions = (options?: Options<GetDashboardOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDashboardOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDashboardOverviewQueryKey(options)
    });
};

export const getCommentsPerDayQueryKey = (options?: Options<GetCommentsPerDayData>) => createQueryKey('getCommentsPerDay', options);

export const getCommentsPerDayOptions = (options?: Options<GetCommentsPerDayData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCommentsPerDay({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCommentsPerDayQueryKey(options)
    });
};

export const getAllDashboardDataQueryKey = (options?: Options<GetAllDashboardDataData>) => createQueryKey('getAllDashboardData', options);

export const getAllDashboardDataOptions = (options?: Options<GetAllDashboardDataData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAllDashboardData({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllDashboardDataQueryKey(options)
    });
};

export const getCommentAnalyticsOverviewQueryKey = (options?: Options<GetCommentAnalyticsOverviewData>) => createQueryKey('getCommentAnalyticsOverview', options);

export const getCommentAnalyticsOverviewOptions = (options?: Options<GetCommentAnalyticsOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCommentAnalyticsOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCommentAnalyticsOverviewQueryKey(options)
    });
};

export const getDailyCommentCountsQueryKey = (options?: Options<GetDailyCommentCountsData>) => createQueryKey('getDailyCommentCounts', options);

export const getDailyCommentCountsOptions = (options?: Options<GetDailyCommentCountsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDailyCommentCounts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDailyCommentCountsQueryKey(options)
    });
};

export const getCategoryAnalyticsOverviewQueryKey = (options?: Options<GetCategoryAnalyticsOverviewData>) => createQueryKey('getCategoryAnalyticsOverview', options);

export const getCategoryAnalyticsOverviewOptions = (options?: Options<GetCategoryAnalyticsOverviewData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCategoryAnalyticsOverview({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCategoryAnalyticsOverviewQueryKey(options)
    });
};

export const getCategoryDistributionQueryKey = (options: Options<GetCategoryDistributionData>) => createQueryKey('getCategoryDistribution', options);

export const getCategoryDistributionOptions = (options: Options<GetCategoryDistributionData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getCategoryDistribution({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getCategoryDistributionQueryKey(options)
    });
};

export const getDailyCategoryCountsQueryKey = (options?: Options<GetDailyCategoryCountsData>) => createQueryKey('getDailyCategoryCounts', options);

export const getDailyCategoryCountsOptions = (options?: Options<GetDailyCategoryCountsData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getDailyCategoryCounts({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getDailyCategoryCountsQueryKey(options)
    });
};

export const getAllQueryKey = (options?: Options<GetAllData>) => createQueryKey('getAll', options);

export const getAllOptions = (options?: Options<GetAllData>) => {
    return queryOptions({
        queryFn: async ({ queryKey, signal }) => {
            const { data } = await getAll({
                ...options,
                ...queryKey[0],
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllQueryKey(options)
    });
};

export const getAllInfiniteQueryKey = (options?: Options<GetAllData>): QueryKey<Options<GetAllData>> => createQueryKey('getAll', options, true);

export const getAllInfiniteOptions = (options?: Options<GetAllData>) => {
    return infiniteQueryOptions<GetAllResponse, AxiosError<DefaultError>, InfiniteData<GetAllResponse>, QueryKey<Options<GetAllData>>, number | Pick<QueryKey<Options<GetAllData>>[0], 'body' | 'headers' | 'path' | 'query'>>(
    // @ts-ignore
    {
        queryFn: async ({ pageParam, queryKey, signal }) => {
            // @ts-ignore
            const page: Pick<QueryKey<Options<GetAllData>>[0], 'body' | 'headers' | 'path' | 'query'> = typeof pageParam === 'object' ? pageParam : {
                query: {
                    page: pageParam
                }
            };
            const params = createInfiniteParams(queryKey, page);
            const { data } = await getAll({
                ...options,
                ...params,
                signal,
                throwOnError: true
            });
            return data;
        },
        queryKey: getAllInfiniteQueryKey(options)
    });
};

export const bulkDeleteRolesMutation = (options?: Partial<Options<BulkDeleteRolesData>>): UseMutationOptions<BulkDeleteRolesResponse, AxiosError<DefaultError>, Options<BulkDeleteRolesData>> => {
    const mutationOptions: UseMutationOptions<BulkDeleteRolesResponse, AxiosError<DefaultError>, Options<BulkDeleteRolesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkDeleteRoles({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkDeletePermissionsMutation = (options?: Partial<Options<BulkDeletePermissionsData>>): UseMutationOptions<BulkDeletePermissionsResponse, AxiosError<DefaultError>, Options<BulkDeletePermissionsData>> => {
    const mutationOptions: UseMutationOptions<BulkDeletePermissionsResponse, AxiosError<DefaultError>, Options<BulkDeletePermissionsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkDeletePermissions({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteAssetMutation = (options?: Partial<Options<DeleteAssetData>>): UseMutationOptions<DeleteAssetResponse, AxiosError<DefaultError>, Options<DeleteAssetData>> => {
    const mutationOptions: UseMutationOptions<DeleteAssetResponse, AxiosError<DefaultError>, Options<DeleteAssetData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteAsset({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkDeleteReportsMutation = (options?: Partial<Options<BulkDeleteReportsData>>): UseMutationOptions<BulkDeleteReportsResponse, AxiosError<DefaultError>, Options<BulkDeleteReportsData>> => {
    const mutationOptions: UseMutationOptions<BulkDeleteReportsResponse, AxiosError<DefaultError>, Options<BulkDeleteReportsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkDeleteReports({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteInteractionMutation = (options?: Partial<Options<DeleteInteractionData>>): UseMutationOptions<DeleteInteractionResponse, AxiosError<DefaultError>, Options<DeleteInteractionData>> => {
    const mutationOptions: UseMutationOptions<DeleteInteractionResponse, AxiosError<DefaultError>, Options<DeleteInteractionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteInteraction({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeTagFromPostMutation = (options?: Partial<Options<RemoveTagFromPostData>>): UseMutationOptions<RemoveTagFromPostResponse, AxiosError<DefaultError>, Options<RemoveTagFromPostData>> => {
    const mutationOptions: UseMutationOptions<RemoveTagFromPostResponse, AxiosError<DefaultError>, Options<RemoveTagFromPostData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeTagFromPost({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkDeleteTagsMutation = (options?: Partial<Options<BulkDeleteTagsData>>): UseMutationOptions<BulkDeleteTagsResponse, AxiosError<DefaultError>, Options<BulkDeleteTagsData>> => {
    const mutationOptions: UseMutationOptions<BulkDeleteTagsResponse, AxiosError<DefaultError>, Options<BulkDeleteTagsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkDeleteTags({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deletePostCategoriesMutation = (options?: Partial<Options<DeletePostCategoriesData>>): UseMutationOptions<DeletePostCategoriesResponse, AxiosError<DefaultError>, Options<DeletePostCategoriesData>> => {
    const mutationOptions: UseMutationOptions<DeletePostCategoriesResponse, AxiosError<DefaultError>, Options<DeletePostCategoriesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deletePostCategories({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const softDeleteNotificationByIdMutation = (options?: Partial<Options<SoftDeleteNotificationByIdData>>): UseMutationOptions<SoftDeleteNotificationByIdResponse, AxiosError<DefaultError>, Options<SoftDeleteNotificationByIdData>> => {
    const mutationOptions: UseMutationOptions<SoftDeleteNotificationByIdResponse, AxiosError<DefaultError>, Options<SoftDeleteNotificationByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await softDeleteNotificationById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const dismissAllNotificationsMutation = (options?: Partial<Options<DismissAllNotificationsData>>): UseMutationOptions<DismissAllNotificationsResponse, AxiosError<DefaultError>, Options<DismissAllNotificationsData>> => {
    const mutationOptions: UseMutationOptions<DismissAllNotificationsResponse, AxiosError<DefaultError>, Options<DismissAllNotificationsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await dismissAllNotifications({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const removeInteractionMutation = (options?: Partial<Options<RemoveInteractionData>>): UseMutationOptions<RemoveInteractionResponse, AxiosError<DefaultError>, Options<RemoveInteractionData>> => {
    const mutationOptions: UseMutationOptions<RemoveInteractionResponse, AxiosError<DefaultError>, Options<RemoveInteractionData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await removeInteraction({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkDeleteUsersMutation = (options?: Partial<Options<BulkDeleteUsersData>>): UseMutationOptions<BulkDeleteUsersResponse, AxiosError<DefaultError>, Options<BulkDeleteUsersData>> => {
    const mutationOptions: UseMutationOptions<BulkDeleteUsersResponse, AxiosError<DefaultError>, Options<BulkDeleteUsersData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkDeleteUsers({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteAllUsersMutation = (options?: Partial<Options<DeleteAllUsersData>>): UseMutationOptions<DeleteAllUsersResponse, AxiosError<DefaultError>, Options<DeleteAllUsersData>> => {
    const mutationOptions: UseMutationOptions<DeleteAllUsersResponse, AxiosError<DefaultError>, Options<DeleteAllUsersData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteAllUsers({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteAllPostsByUserMutation = (options?: Partial<Options<DeleteAllPostsByUserData>>): UseMutationOptions<DeleteAllPostsByUserResponse, AxiosError<DefaultError>, Options<DeleteAllPostsByUserData>> => {
    const mutationOptions: UseMutationOptions<DeleteAllPostsByUserResponse, AxiosError<DefaultError>, Options<DeleteAllPostsByUserData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteAllPostsByUser({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkDeleteNotificationsMutation = (options?: Partial<Options<BulkDeleteNotificationsData>>): UseMutationOptions<BulkDeleteNotificationsResponse, AxiosError<DefaultError>, Options<BulkDeleteNotificationsData>> => {
    const mutationOptions: UseMutationOptions<BulkDeleteNotificationsResponse, AxiosError<DefaultError>, Options<BulkDeleteNotificationsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkDeleteNotifications({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const forceDeleteNotificationByIdMutation = (options?: Partial<Options<ForceDeleteNotificationByIdData>>): UseMutationOptions<ForceDeleteNotificationByIdResponse, AxiosError<DefaultError>, Options<ForceDeleteNotificationByIdData>> => {
    const mutationOptions: UseMutationOptions<ForceDeleteNotificationByIdResponse, AxiosError<DefaultError>, Options<ForceDeleteNotificationByIdData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await forceDeleteNotificationById({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const bulkDeleteLogEntriesMutation = (options?: Partial<Options<BulkDeleteLogEntriesData>>): UseMutationOptions<BulkDeleteLogEntriesResponse, AxiosError<DefaultError>, Options<BulkDeleteLogEntriesData>> => {
    const mutationOptions: UseMutationOptions<BulkDeleteLogEntriesResponse, AxiosError<DefaultError>, Options<BulkDeleteLogEntriesData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await bulkDeleteLogEntries({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteMultipleCommentsMutation = (options?: Partial<Options<DeleteMultipleCommentsData>>): UseMutationOptions<DeleteMultipleCommentsResponse, AxiosError<DefaultError>, Options<DeleteMultipleCommentsData>> => {
    const mutationOptions: UseMutationOptions<DeleteMultipleCommentsResponse, AxiosError<DefaultError>, Options<DeleteMultipleCommentsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteMultipleComments({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};

export const deleteAllCommentsMutation = (options?: Partial<Options<DeleteAllCommentsData>>): UseMutationOptions<DeleteAllCommentsResponse, AxiosError<DefaultError>, Options<DeleteAllCommentsData>> => {
    const mutationOptions: UseMutationOptions<DeleteAllCommentsResponse, AxiosError<DefaultError>, Options<DeleteAllCommentsData>> = {
        mutationFn: async (localOptions) => {
            const { data } = await deleteAllComments({
                ...options,
                ...localOptions,
                throwOnError: true
            });
            return data;
        }
    };
    return mutationOptions;
};